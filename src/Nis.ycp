/**
 * File:
 *   modules/Nis.ycp
 *
 * Module:
 *   Configuration of NIS client
 *
 * Summary:
 *   NIS client configuration data, I/O functions.
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *   Dan Vesely <dan@suse.cz>
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 */

{
    module "Nis";
    textdomain "nis";

    import "Runlevel";
    import "Report";
    import "Summary";
    include "network/dns.ycp";

    /**
     * Should ypbind be started at boot?
     * If not, other settings are not touched.
     */
    global boolean start = false;

    /**
     * IP addresses of NIS servers.
     */
    global list(string) servers = [];

    /**
     * @return Access the servers as a string
     */
    global define string GetServers () ``{
	return mergestring (servers, " ");
    }

    /**
     * Set the servers from a string
     * @param servers_s a whitespace separated list
     */
    global define void SetServers (string servers_s) ``{
	servers = filter (`s, splitstring (servers_s, " \t"), ``(s != ""));
    }

    /**
     * Broadcast for the default domain?
     * (New in ypbind-1.12)
     */
    global boolean default_broadcast = false;

    /**
     * Servers for a multiple-domain configuration.
     * Keys are domains, values are lists of servers (strings).
     * The domains must be the same as for multidomain_broadcast
     * @see multidomain_broadcast
     */
    global map multidomain_servers = $[];

    /**
     * Servers for a multiple-domain configuration.
     * Whether a broadcast will be done if the servers don't respond.
     * Keys are domains, values are booleans.
     * The domains must be the same as for multidomain_servers
     * @see multidomain_servers
     * @see global_broadcast
     */
    global map multidomain_broadcast = $[];

    string domain = "";
    string old_domain = nil;
    boolean domain_changed = false;

    /**
     * If the domain has changed from a nonempty one, it may only be
     * changed at boot time. Use this to warn the user.
     * @return whether changed by SetDomain
     */
    global define boolean DomainChanged () ``{
	return domain_changed;
    }

    /**
     * @return Get the NIS domain.
     */
    global define string GetDomain () ``{
	return domain;
    }

    /**
     * Set the NIS domain.
     * @param new_domain a new domain
     */
    global define void SetDomain (string new_domain) ``{
	domain = new_domain;
	if (domain != old_domain && old_domain != "")
	{
	    domain_changed = true;
	}
    }

    // The following four are from sysconfig/ypbind; the comments are
    // taken from there. The dialog help texts have "user friendlier"
    // descriptions.

    /**
     * If this option is set, ypbind will only bind to the loopback
     * interface and remote hosts cannot query it.
     */
    global boolean local_only = false;

    /**
     * If this option is set, ypbind will ignore /etc/yp.conf and use
     * a broadcast call to find a NIS server in the local subnet. You
     * should avoid to use this, it is a big security risk.
     * @see multidomain_broadcast
     * @see default_broadcast
     */
    global boolean global_broadcast = false;

    /**
     * You should set this to "yes" if you have a NIS server in your
     * network, which binds only to high ports over 1024. Since this
     * is a security risk, you should consider to replace the NIS
     * server with another implementation.
     */
    global boolean broken_server = false;

    /**
     * Extra options for ypbind. Here you can add options like
     * "-ypset", "-ypsetme", "-p port" or "-no-ping".
     */
    global string options = "";

    /**
     * If no, automounter will not be affected.
     */
    global boolean _autofs_allowed = false;
    /**
     * Start automounter and import the settings from NIS. (Bug 6092)
     */
    global boolean _start_autofs = false;

    /**
     * Output of "rcypbind start", if there was an error.
     * Read only.
     * This is currently used only in nis-server for its more advanced
     * error reporting. (Bug 14706)
     */
    global string YpbindErrors = "";

    /* ---------------------------------------------------------------- */
    // used also for nis-server

    /**
     * Check syntax of a NIS domain name
     * @param domain	a domain name
     * @return		true if correct
     */
    global define boolean check_nisdomainname (string domain) ``{
	// TODO
	// disallow whitespace and special characters...
	return domain != "" && domain != "(none)" && size (domain) <= 64;
    }

    /**
     * @return describe a valid NIS domain name
     */
    global define string valid_nisdomainname () ``{
	// Translators: do not translate (none)!
	return _("A NIS domain name must not be empty,
it must not be \"(none)\",
and it must be at most 64 characters long.
");
    }

    /**
     * If the hostname resolution is done over NIS,
     * names cannot be used to specify servers.
     */
    boolean hosts_by_nis = false;

    /**
     * Describe a valid address - ip4 or name, names only if
     * nsswitch.conf does not have hosts: nis
     * @return a description
     */
    global define string valid_address_nis () ``{
	y2debug ("hosts_by_nis %1", hosts_by_nis);
	if (hosts_by_nis)
	{
	    return _("Only an IP address can be used
because host names are resolved using NIS.\n\n") + valid_ip4 ();
	}
	else
	{
	    return valid_address ();
	}
    }

    /**
     * Check syntax of a network address (ip4 or name), names only if
     * nsswitch.conf does not have hosts: nis
     * @param a an address
     * @return true if correct
     */
    global define boolean check_address_nis (string a) ``{
	y2debug ("hosts_by_nis %1", hosts_by_nis);
	if (hosts_by_nis)
	{
	    return check_ip4 (a);
	}
	else
	{
	    return check_address (a);
	}
    }

    /* ---------------------------------------------------------------- */

    /**
     * Has the configuration been changed?
     * Can be used as an argument to UI::ReallyAbortPopup
     */
    global boolean touched = false;

    /**
     * A convenient shortcut for setting touched.
     * @param really	if true, set Nis::touched
     * @example Nis::Touch (Nis::var != ui_var);
     */
    global define void Touch (boolean really) ``{
	touched = touched || really;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Read only, set by ProbePackages.
     * Use as an argument to require.ycp/DoInstallAndRemove
     */
    global list(string) install_packages = [];
    /**
     * Read only, set by ProbePackages.
     * Use as an argument to require.ycp/DoInstallAndRemove
     */
    global list(string) remove_packages = [];

    /**
     * Detect which packages have to be installed
     * and return a descriptive string for a plain text pop-up.
     * @return "" or "Foo will be installed.\nBar will be installed.\n"
     */
    global define string ProbePackages () ``{
	string message = "";
	install_packages = [];
	remove_packages = [];

	if (_autofs_allowed && _start_autofs)
	{
	    string pkg = "autofs";
	    if (! SCR::Read (.targetpkg.installed, pkg))
	    {
		install_packages = add (install_packages, pkg);
		// Translators: popup message part, ends with a newline
		message = message + _("The automounter package will be installed.\n");
	    }
	}

	return message;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Set module data
     * @return void
     */
    global define void Set (map settings) ``{
	start = settings["start_nis"]:false;

	servers = settings["nis_servers"]:[];
	default_broadcast = settings["nis_broadcast"]:false;
	domain = settings["nis_domain"]:"";
	old_domain = domain;

	list other_domains = settings["nis_other_domains"]:[];
	foreach (map other_domain, other_domains, ``{
	    string d = other_domain["nis_domain"]:"";
	    list(string) s = other_domain["nis_servers"]:[];
	    boolean b = other_domain["nis_broadcast"]:false;
	    multidomain_servers = add (multidomain_servers, d, s);
	    multidomain_broadcast = add (multidomain_broadcast, d, b);
	});

	local_only = settings["nis_local_only"]:false;
	broken_server = settings["nis_broken_server"]:false;
	options = settings["nis_options"]:"";

	// autofs is not touched in Write if the map does not want it
	_autofs_allowed = haskey (settings, "start_autofs");
	_start_autofs = settings["start_autofs"]:false;
    }

    // TODO update the map keys
    // better still: link to a current interface description
    /**
     * Get all the NIS configuration from a map.
     * When called by nis_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	$["start": "domain": "servers":[...] ]
     * @return	success
     */
    global define boolean Import (map settings) ``{
	if (size (settings) == 0)
	{
	    //Provide defaults for autoinstallation editing:
	    //Leave empty.
	    old_domain = domain;
	    return true;
	}

	boolean missing = false;
	foreach (`k, ["start_nis", "nis_domain"], ``{
	    if (! haskey (settings, k))
	    {
		y2error ("Missing at Import: '%1'.", k);
		missing = true;
	    }
	});
	if (missing)
	{
	    return false;
	}

	Set(settings);
	return true;
    }

    // TODO update the map keys
    // better still: link to a current interface description
    /**
     * Dump the NIS settings to a map, for autoinstallation use.
     * @return $["start":, "servers":[...], "domain":]
     */
    global define map Export () ``{
	list other_domains = maplist (string d, list s, multidomain_servers, ``{
	    return $[
		"nis_domain": d,
		"nis_servers": s,
		"nis_broadcast": multidomain_broadcast[d]:false,
		];
	});

	if (global_broadcast)
	{
	    y2error ("Attempt to export Nis::global_broadcast");
	}

	return $[
	    "start_nis": start,

	    "nis_servers": servers,
	    "nis_domain": domain,
	    "nis_broadcast": default_broadcast,

	    "nis_other_domains": other_domains,

	    "nis_local_only": local_only,
	    "nis_broken_server": broken_server,
	    "nis_options": options,

	    "start_autofs": _start_autofs,
	    ];
    }

    /**
     * @return Html formatted configuration summary
     */
    global define string Summary () ``{
	// TODO multidomain_servers, multidomain_broadcast
	// OK, a dumb mapping is possible, but wouldn't it be
	// too complicated to write by hand?
	string summary = "";
	string nc = Summary::NotConfigured ();
	summary = Summary::AddHeader(summary, _("NIS Client enabled"));
	summary = Summary::AddLine(summary, (start) ? _("Yes") : nc);
	summary = Summary::AddHeader(summary, _("NIS Domain"));
	summary = Summary::AddLine(summary, (domain != "") ? domain : nc);
	summary = Summary::AddHeader(summary, _("NIS Servers"));
	summary = Summary::AddLine(summary,(servers !=[]) ? mergestring(servers,"<br>") : nc);
	summary = Summary::AddHeader(summary, _("Broadcast"));
	summary = Summary::AddLine(summary, (default_broadcast) ? _("Yes") : nc);
	// TODO: a full list
	summary = summary + ListItem (_("Other domains"), multidomain_servers);
	summary = Summary::AddHeader(summary, _("Answer to local host only"));
	summary = Summary::AddLine(summary, (local_only) ? _("Yes") : nc);
	summary = Summary::AddHeader(summary, _("Broken server"));
	summary = Summary::AddLine(summary, (broken_server) ? _("Yes") : nc);
	summary = Summary::AddHeader(summary, _("ypbind options"));
	summary = Summary::AddLine(summary, (options!="") ? options : nc);
	summary = Summary::AddHeader(summary, _("Automounter enabled"));
	summary = Summary::AddLine(summary, (_start_autofs) ? _("Yes") : nc);

	return summary;
    }

    // copied from Mail.ycp
    // replace with a custom list
    /**
     * Summarizes a list of data
     * @param title passed to Summary::AddHeader
     * @param value a list (of scalars, lists or maps)
     * @return Summary-formatted description
     */
    define string ListItem(string title, any value) ``{
	string summary = "";
	summary = Summary::AddHeader(summary, title);
	//enhancement BEGIN
	if (is (value, map))
	{
	    value = maplist (any k, any v, value, ``(k));
	}
	//enhancement END
	if (is(value,list) && size(value)>0) {
	    summary = Summary::OpenList(summary);
	    foreach (`d, value, ``{
		string entry = "";
		if (is(d,map) || is (d,list))
		    entry = sformat("%1 Entries configured", size(value));
		else
		    entry = d;

		summary = Summary::AddListItem(summary, entry);
	    });
	    summary = Summary::CloseList(summary);
	} else {
	    summary = Summary::AddLine(summary,Summary::NotConfigured ());
	}
	return summary;
    }

    /**
     * Reads NIS settings from the SCR
     * @return success
     */
    global define boolean Read () ``{
	start = Runlevel::ServiceEnabled ("ypbind");
	servers = SCR::Read (.etc.yp_conf.servers);
	default_broadcast = SCR::Read (.etc.yp_conf.defaultbroadcast);
	multidomain_servers = SCR::Read (.etc.yp_conf.domainservers);
	multidomain_broadcast = SCR::Read (.etc.yp_conf.broadcast);
	domain  = SCR::Read (.etc.defaultdomain);
	//TODO: ypdomainname (dhcpcd does not use defaultdomain)
	old_domain = domain;
	local_only = SCR::Read (.sysconfig.ypbind.YPBIND_LOCAL_ONLY) == "yes";
	global_broadcast = SCR::Read (.sysconfig.ypbind.YPBIND_BROADCAST) == "yes";
	broken_server = SCR::Read (.sysconfig.ypbind.YPBIND_BROKEN_SERVER) == "yes";
	options = SCR::Read (.sysconfig.ypbind.YPBIND_OPTIONS);

	// install on demand
	_autofs_allowed = true;
	/*
	_autofs_allowed =
	    SCR::Read (.targetpkg.installed, "autofs") ||
	    SCR::Read (.targetpkg.installed, "autofs4");
	*/
	_start_autofs = _autofs_allowed && Runlevel::ServiceEnabled ("autofs");

	string hosts_s = SCR::Read (.etc.nsswitch_conf.hosts);
	list(string) hosts_l = filter (`s, splitstring (hosts_s, " \t"), ``(s != ""));
	hosts_by_nis = find (string s, hosts_l, ``(s == "nis")) != nil;

	return true;
    }

    /**
     * Only write new configuration w/o starting any scripts
     * @return true on success
     */
    global define boolean WriteOnly()``{
	if (start)
	{
	    Runlevel::ServiceAdjust ("portmap", "enable");
	    Runlevel::ServiceAdjust ("ypbind", "enable");

	    if (!SCR::Write (.etc.defaultdomain, domain))
	    {
		Report::Error (sformat (_("Error writing file %1."), "/etc/defaultdomain"));
		return false;
	    }
	    SCR::Write (.etc.yp_conf.servers, servers);
	    SCR::Write (.etc.yp_conf.defaultbroadcast, default_broadcast);
	    SCR::Write (.etc.yp_conf.domainservers, multidomain_servers);
	    SCR::Write (.etc.yp_conf.broadcast, multidomain_broadcast);
	    if (! SCR::Write (.etc.yp_conf, nil))
	    {
		Report::Error (sformat (_("Error writing file %1."), "/etc/yp.conf"));
		return false;
	    }
	    SCR::Write (.sysconfig.ypbind.YPBIND_LOCAL_ONLY, local_only? "yes":"no");
	    SCR::Write (.sysconfig.ypbind.YPBIND_BROADCAST, global_broadcast? "yes":"no");
	    SCR::Write (.sysconfig.ypbind.YPBIND_BROKEN_SERVER, broken_server? "yes":"no");
	    SCR::Write (.sysconfig.ypbind.YPBIND_OPTIONS, options);
	    if (! SCR::Write (.sysconfig.ypbind, nil))
	    {
		Report::Error (sformat (_("Error writing file %1."), "/etc/sysconfig/ypbind"));
		return false;
	    }
	}
	else
	{
	    Runlevel::ServiceAdjust ("ypbind", "disable");
	}

	if (start)
	{
	    if (! WritePluses ())
	    {
		return false;
	    }

	    if (_autofs_allowed)
	    {
		// nsswitch automount:
		// bracket options not allowed, order does not matter
		string automount_s = SCR::Read (.etc.nsswitch_conf.automount);
		list(string) automount_l = filter (`s, splitstring (automount_s, " \t"), ``(s != ""));
		boolean enabled = find (string s, automount_l, ``(s == "nis")) != nil;
		boolean ok = true;
		if (_start_autofs && !enabled)
		{
		    ok = SCR::Write (.etc.nsswitch_conf.automount, automount_s + " nis");
		    ok = ok && SCR::Write (.etc.nsswitch_conf, nil);
		}
		else if (!_start_autofs && enabled)
		{
		    automount_l = filter (string s, automount_l, ``(s != "nis"));
		    ok = SCR::Write (.etc.nsswitch_conf.automount, mergestring (automount_l, " "));
		    ok = ok && SCR::Write (.etc.nsswitch_conf, nil);
		}
		if (!ok)
		{
		    Report::Error (sformat (_("Error writing file %1."), "/etc/nsswitch.conf"));
		    return false;
		}

		if (_start_autofs)
		{
		    Runlevel::ServiceAdjust ("autofs", "enable");
		}
		else
		{
		    Runlevel::ServiceAdjust ("autofs", "disable");
		}
	    }
	}
	return true;
    }


    /**
     * Saves NIS configuration.
     * @return true on success
     */
    global define boolean Write () ``{
	if (!WriteOnly ())
	{
	    return false;
	}

	Runlevel::RunInitScript ("ypbind", "stop");

	if (start)
	{
	    if (Runlevel::ServiceStatus ("portmap") != 0 )
	    {
		// portmap must not be started if it is running already (see bug # 9999)
		if (Runlevel::RunInitScript ("portmap", "start") != 0)
		{
		    // error popup message
		    Report::Error (_("Error while running portmapper."));
		    return false;
		}
	    }
	    sleep(1000);	// workaround for bug #10428, ypbind restart

	    map out = SCR::Execute (.target.bash_output, "/etc/init.d/ypbind start", $["TERM": "raw"]);
	    if (out["exit"]:1 == 0)
	    {
		YpbindErrors = "";
	    }
	    else
	    {
		YpbindErrors = out["stdout"]:"internal error";
		// error popup message
		Report::Error (_("Error while running ypclient."));
		return false;
	    }

	    // only test for a server if domain not changed
	    if (! domain_changed)
	    {
		if (SCR::Execute(.target.bash, "/usr/bin/ypwhich >/dev/null") != 0)
		{
		    // error popup message
		    Report::Error (_("NIS server not found."));
		    return false;
		}
	    }

	    if (_autofs_allowed)
	    {
		Runlevel::RunInitScript ("autofs", "stop");

		if (_start_autofs)
		{
		    Runlevel::RunInitScript ("autofs", "start");
		}
	    }
	}
	return true;
    }

    /**
     * Add "+" lines to system files so that NIS entries get merged in.
     * (Formerly this was done in SuSEconfig.ypclient)
     * @return success?
     */
    define boolean WritePluses () ``{
	list(string) files = [];
	if (SCR::Read (.etc.nsswitch_conf.passwd) == "compat")
	{
	    files = ["passwd", "shadow"];
	}
	if (SCR::Read (.etc.nsswitch_conf.group) == "compat")
	{
	    files = add (files, "group");
	}

	//don't forget a newline
	map what_to_write = $[
	    "passwd":	"+::::::",
	    "group":	"+:::",
	    "shadow":	"+",
	    ];
	foreach (string f, files, ``{
	    if (! WritePlusesTo (sformat ("/etc/%1", f), what_to_write[f]:""))
	    {
		return false;
	    }
	});
	return true;
    }

    /**
     * If a file does not contain a NIS entry, add it.
     * @param	file	pathname
     * @param	what	a "+" line without a '\n'
     * @return success?
     */
    define boolean WritePlusesTo (string file, string what) ``{
	if (SCR::Execute (.target.bash, "/usr/bin/grep -q '^[+-]' " + file) != 0)
	{
	    // not there, add it
	    // TODO: backup?
	    if (SCR::Execute (.target.bash, sformat ("/bin/echo '%1' >> %2", what, file)) != 0)
	    {
		Report::Error (sformat (_("Error writing file %1."), file));
		return false;
	    }
	}
	return true;
    }
}
