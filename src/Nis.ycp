/**
 * File:
 *   modules/Nis.ycp
 *
 * Module:
 *   Configuration of NIS client
 *
 * Summary:
 *   NIS client configuration data, I/O functions.
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *   Dan Vesely <dan@suse.cz>
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 */

{
    module "Nis";
    textdomain "nis";

    import "Runlevel";
    import "Report";

    /**
     * Should ypbind be started at boot?
     * If not, other settings are not touched.
     */
    global boolean start = false;

    /**
     * IP addresses of NIS servers.
     */
    global list(string) servers = [];

    /**
     * @return Access the servers as a string
     */
    global define string GetServers () ``{
	return mergestring (servers, " ");
    }

    /**
     * Set the servers from a string
     * @param servers_s a whitespace separated list
     */
    global define void SetServers (string servers_s) ``{
	servers = filter (`s, splitstring (servers_s, " \t"), ``(s != ""));
    }

    string domain = "";
    string old_domain = nil;
    boolean domain_changed = false;

    /**
     * If the domain has changed from a nonempty one, it may only be
     * changed at boot time. Use this to warn the user.
     * @return whether changed by SetDomain
     */
    global define boolean DomainChanged () ``{
	return domain_changed;
    }

    /**
     * @return Get the NIS domain.
     */
    global define string GetDomain () ``{
	return domain;
    }

    /**
     * Set the NIS domain.
     * @param new_domain a new domain
     */
    global define void SetDomain (string new_domain) ``{
	domain = new_domain;
	if (domain != old_domain && old_domain != "")
	{
	    domain_changed = true;
	}
    }

    /**
     * If no, automounter will not be affected.
     */
    global boolean _autofs_allowed = false;
    /**
     * Start automounter and import the settings from NIS. (Bug 6092)
     */
    global boolean _start_autofs = false;

    /* ---------------------------------------------------------------- */

    /**
     * Get all the NIS configuration from a map.
     * When called by nis_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	$["start": "domain": "servers":[...] ]
     * @return	success
     */
    global define boolean Import (map settings) ``{
	if (size (settings) == 0)
	{
	    //Provide defaults for autoinstallation editing:
	    //Leave empty.
	    old_domain = domain;
	    return true;
	}

	boolean missing = false;
	foreach (`k, ["start_nis", "nis_domain", "nis_servers"], ``{
	    if (! haskey (settings, k))
	    {
		y2error ("Missing at Import: '%1'.", k);
		missing = true;
	    }
	});
	if (missing)
	{
	    return false;
	}

	start = lookup (settings, "start_nis", false);
	servers = lookup (settings, "nis_servers", []);
	domain = lookup (settings, "nis_domain", "");
	old_domain = domain;
	// autofs is not touched in Write if the map does not want it
	_autofs_allowed = haskey (settings, "start_autofs");
	_start_autofs = lookup (settings, "start_autofs", false);
	return true;
    }

    /**
     * Dump the NIS settings to a map, for autoinstallation use.
     * @return $["start":, "servers":[...], "domain":]
     */
    global define map Export () ``{
	return $[
	    "start_nis": start,
	    "nis_servers": servers,
	    "nis_domain": domain,
	    "start_autofs": _start_autofs,
	    ];
    }

    /**
     * Reads NIS settings from the SCR
     * @return success
     */
    global define boolean Read () ``{
	start = Runlevel::ServiceEnabled ("ypbind");
	servers = SCR::Read (.etc.yp_conf.servers);
	domain  = SCR::Read (.etc.defaultdomain);
	old_domain = domain;

	_autofs_allowed =
	    SCR::Read (.targetpkg.installed, "autofs") ||
	    SCR::Read (.targetpkg.installed, "autofs4");
	_start_autofs = Runlevel::ServiceEnabled ("autofs");
	return true;
    }

    /**
     * Only write new configuration w/o starting any scripts
     * @return true on success
     */
    global define boolean WriteOnly()``{
	return (Write(true));
    }

    /**
     * Saves NIS configuration.
     * @param writeonly	 true for autoinstal - don't start the service yet
     * @return true on success
     */
    global define boolean Write (boolean writeonly) ``{
	if (!writeonly)
	{
	    Runlevel::RunInitScript ("ypbind", "stop");
	}

	if (start)
	{
	    Runlevel::ServiceAdjust ("portmap", "enable");
	    Runlevel::ServiceAdjust ("ypbind", "enable");

	    if (SCR::Write (.etc.defaultdomain, domain) == nil)
	    {
		Report::Error (sformat (_("Error writing file %1."), "/etc/defaultdomain"));
		return false;
	    }
	    SCR::Write (.etc.yp_conf.servers, servers);
	    if (! SCR::Write (.etc.yp_conf, nil))
	    {
		Report::Error (sformat (_("Error writing file %1."), "/etc/yp.conf"));
		return false;
	    }

	}
	else
	{
	    Runlevel::ServiceAdjust ("ypbind", "disable");
	}

	if (start)
	{
	    if (! WritePluses ())
	    {
		return false;
	    }

	    if (!writeonly && Runlevel::ServiceStatus ("portmap") != 0 )
	    {
		// portmap must not be started if it is running already (see bug # 9999)
		if (Runlevel::RunInitScript ("portmap", "start") != 0)
		{
		    // error popup message
		    Report::Error (_("Error while running portmapper."));
		    return false;
		}
	    }
	    sleep(1000);	// workaround for bug #10428, ypbind restart
	    if (!writeonly && Runlevel::RunInitScript ("ypbind", "start") != 0)
	    {
		// error popup message
		Report::Error (_("Error while running ypclient."));
		return false;
	    }
	    // only test for a server if domain not changed
	    if (! domain_changed && !writeonly)
	    {
		if (SCR::Execute(.target.bash, "/usr/bin/ypwhich >/dev/null") != 0)
		{
		    // error popup message
		    Report::Error (_("NIS server not found."));
		    return false;
		}
	    }

	    if (_autofs_allowed)
	    {
		if (!writeonly)
		{
		    Runlevel::RunInitScript ("autofs", "stop");
		}

		// nsswitch automount:
		// bracket options not allowed, order does not matter
		string automount_s = SCR::Read (.etc.nsswitch_conf.automount);
		list(string) automount_l = filter (`s, splitstring (automount_s, " \t"), ``(s != ""));
		boolean enabled = find (string s, automount_l, ``(s == "nis")) != nil;
		boolean ok = true;
		if (_start_autofs && !enabled)
		{
		    ok = SCR::Write (.etc.nsswitch_conf.automount, automount_s + " nis");
		}
		else if (!_start_autofs && enabled)
		{
		    automount_l = filter (string s, automount_l, ``(s != "nis"));
		    ok = SCR::Write (.etc.nsswitch_conf.automount, mergestring (automount_l, " "));
		}
		if (!ok)
		{
		    Report::Error (sformat (_("Error writing file %1."), "/etc/nsswitch.conf"));
		    return false;
		}

		if (_start_autofs && !writeonly)
		    Runlevel::RunInitScript ("autofs", "start");

		if (_start_autofs)
		{
		    Runlevel::ServiceAdjust ("autofs", "enable");
		}
		else
		{
		    Runlevel::ServiceAdjust ("autofs", "disable");
		}
	    }
	}
	return true;
    }

    /**
     * Add "+" lines to system files so that NIS entries get merged in.
     * (Formerly this was done in SuSEconfig.ypclient)
     * @return success?
     */
    define boolean WritePluses () ``{
	list(string) files = [];
	if (SCR::Read (.etc.nsswitch_conf.passwd) == "compat")
	{
	    files = ["passwd", "shadow"];
	}
	if (SCR::Read (.etc.nsswitch_conf.group) == "compat")
	{
	    files = add (files, "group");
	}

	//don't forget a newline
	map what_to_write = $[
	    "passwd":	"+::::::",
	    "group":	"+:::",
	    "shadow":	"+",
	    ];
	foreach (string f, files, ``{
	    if (! WritePlusesTo (sformat ("/etc/%1", f), what_to_write[f]:""))
	    {
		return false;
	    }
	});
	return true;
    }

    /**
     * If a file does not contain a NIS entry, add it.
     * @param	file	pathname
     * @param	what	a "+" line without a '\n'
     * @return success?
     */
    define boolean WritePlusesTo (string file, string what) ``{
	if (SCR::Execute (.target.bash, "/usr/bin/grep -q '^[+-]' " + file) != 0)
	{
	    // not there, add it
	    // TODO: backup?
	    if (SCR::Execute (.target.bash, sformat ("/bin/echo '%1' >> %2", what, file)) != 0)
	    {
		Report::Error (sformat (_("Error writing file %1."), file));
		return false;
	    }
	}
	return true;
    }
}
