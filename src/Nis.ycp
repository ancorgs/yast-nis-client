/**
 * File:
 *   modules/Nis.ycp
 *
 * Module:
 *   Configuration of NIS client
 *
 * Summary:
 *   NIS client configuration data, I/O functions.
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *   Dan Vesely <dan@suse.cz>
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 */

{
    module "Nis";
    textdomain "nis";

    import "Runlevel";
    import "Report";
    import "Summary";
    include "network/dns.ycp";
    include "require.ycp";

    /**
     * Should ypbind be started at boot?
     * If not, other settings are not touched.
     */
    global boolean start = false;

    /**
     * IP addresses of NIS servers.
     */
    global list(string) servers = [];

    /**
     * @return Access the servers as a string
     */
    global define string GetServers () ``{
	return mergestring (servers, " ");
    }

    /**
     * Set the servers from a string
     * @param servers_s a whitespace separated list
     */
    global define void SetServers (string servers_s) ``{
	servers = filter (`s, splitstring (servers_s, " \t"), ``(s != ""));
    }

    /**
     * Broadcast for the default domain?
     * (New in ypbind-1.12)
     */
    global boolean default_broadcast = false;

    /**
     * Servers for a multiple-domain configuration.
     * Keys are domains, values are lists of servers (strings).
     * The domains must be the same as for multidomain_broadcast
     * @see multidomain_broadcast
     */
    global map multidomain_servers = $[];

    /**
     * Servers for a multiple-domain configuration.
     * Whether a broadcast will be done if the servers don't respond.
     * Keys are domains, values are booleans.
     * The domains must be the same as for multidomain_servers
     * @see multidomain_servers
     * @see global_broadcast
     */
    global map multidomain_broadcast = $[];

    string domain = "";
    string old_domain = nil;
    boolean domain_changed = false;

    /**
     * If the domain has changed from a nonempty one, it may only be
     * changed at boot time. Use this to warn the user.
     * @return whether changed by SetDomain
     */
    global define boolean DomainChanged () ``{
	return domain_changed;
    }

    /**
     * @return Get the NIS domain.
     */
    global define string GetDomain () ``{
	return domain;
    }

    /**
     * Set the NIS domain.
     * @param new_domain a new domain
     */
    global define void SetDomain (string new_domain) ``{
	domain = new_domain;
	if (domain != old_domain && old_domain != "")
	{
	    domain_changed = true;
	}
    }

    // DHCP cooperation

    /**
     * Whether sysconfig/network/dhcp says to get yp.conf by DHCP
     */
    global boolean servers_by_dhcp_wanted = false;
    /**
     * Whether sysconfig/network/dhcp says to get the domain by DHCP
     */
    global boolean domain_by_dhcp_wanted = false;
    /**
     * Is yp.conf currently served by DHCP and thus disabled in the UI
     */
    boolean servers_by_dhcp_actual = false;
    /**
     * Is domain currently served by DHCP and thus disabled in the UI
     */
    boolean domain_by_dhcp_actual = false;
    /**
     * In autoinst mode, the _actual variables are overriden by their
     * _wanted counterparts
     */
    boolean auto_mode = false;
    /**
     * Is yp.conf currently served by DHCP and thus disabled in the UI
     */
    global define boolean ServersByDhcpActual () ``{
	return auto_mode? servers_by_dhcp_wanted : servers_by_dhcp_actual;
    }
    /**
     * Is domain currently served by DHCP and thus disabled in the UI
     */
    global define boolean DomainByDhcpActual () ``{
	return auto_mode? domain_by_dhcp_wanted : domain_by_dhcp_actual;
    }
    /**
     * If *_by_dhcp_wanted changes, we need to restart the DHCP client
     */
    global boolean dhcp_restart = false;

    // The following four are from sysconfig/ypbind; the comments are
    // taken from there. The dialog help texts have "user friendlier"
    // descriptions.

    /**
     * If this option is set, ypbind will only bind to the loopback
     * interface and remote hosts cannot query it.
     */
    global boolean local_only = false;

    /**
     * If this option is set, ypbind will ignore /etc/yp.conf and use
     * a broadcast call to find a NIS server in the local subnet. You
     * should avoid to use this, it is a big security risk.
     * @see multidomain_broadcast
     * @see default_broadcast
     */
    global boolean global_broadcast = false;

    /**
     * You should set this to "yes" if you have a NIS server in your
     * network, which binds only to high ports over 1024. Since this
     * is a security risk, you should consider to replace the NIS
     * server with another implementation.
     */
    global boolean broken_server = false;

    /**
     * Extra options for ypbind. Here you can add options like
     * "-ypset", "-ypsetme", "-p port" or "-no-ping".
     */
    global string options = "";

    /**
     * If no, automounter will not be affected.
     */
    global boolean _autofs_allowed = false;
    /**
     * Start automounter and import the settings from NIS. (Bug 6092)
     */
    global boolean _start_autofs = false;

    /**
     * Output of "rcypbind start", if there was an error.
     * Read only.
     * This is currently used only in nis-server for its more advanced
     * error reporting. (Bug 14706)
     */
    global string YpbindErrors = "";

    /* ---------------------------------------------------------------- */
    // used also for nis-server

    /**
     * Check syntax of a NIS domain name
     * @param domain	a domain name
     * @return		true if correct
     */
    global define boolean check_nisdomainname (string domain) ``{
	// TODO
	// disallow whitespace and special characters...
	return domain != "" && domain != "(none)" && size (domain) <= 64;
    }

    /**
     * @return describe a valid NIS domain name
     */
    global define string valid_nisdomainname () ``{
	// Translators: do not translate (none)!
	return _("A NIS domain name must not be empty,
it must not be \"(none)\",
and it must be at most 64 characters long.
");
    }

    /**
     * If the hostname resolution is done over NIS,
     * names cannot be used to specify servers.
     */
    boolean hosts_by_nis = false;

    /**
     * Describe a valid address - ip4 or name, names only if
     * nsswitch.conf does not have hosts: nis
     * @return a description
     */
    global define string valid_address_nis () ``{
	y2debug ("hosts_by_nis %1", hosts_by_nis);
	if (hosts_by_nis)
	{
	    // message popup
	    return _("Only an IP address can be used
because host names are resolved using NIS.\n\n") + valid_ip4 ();
	}
	else
	{
	    return valid_address ();
	}
    }

    /**
     * Check syntax of a network address (ip4 or name), names only if
     * nsswitch.conf does not have hosts: nis
     * @param a an address
     * @return true if correct
     */
    global define boolean check_address_nis (string a) ``{
	y2debug ("hosts_by_nis %1", hosts_by_nis);
	if (hosts_by_nis)
	{
	    return check_ip4 (a);
	}
	else
	{
	    return check_address (a);
	}
    }

    /* ---------------------------------------------------------------- */

    /**
     * Has the configuration been changed?
     * Can be used as an argument to UI::ReallyAbortPopup
     */
    global boolean touched = false;

    /**
     * A convenient shortcut for setting touched.
     * @param really	if true, set Nis::touched
     * @example Nis::Touch (Nis::var != ui_var);
     */
    global define void Touch (boolean really) ``{
	touched = touched || really;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Read only, set by ProbePackages.
     * Use as an argument to require.ycp/DoInstallAndRemove
     */
    global list(string) install_packages = [];
    /**
     * Read only, set by ProbePackages.
     * Use as an argument to require.ycp/DoInstallAndRemove
     */
    global list(string) remove_packages = [];

    /**
     * Detect which packages have to be installed
     * and return a descriptive string for a plain text pop-up.
     * @return "" or "Foo will be installed.\nBar will be installed.\n"
     */
    global define string ProbePackages () ``{
	string message = "";
	install_packages = [];
	remove_packages = [];

	if (_autofs_allowed && _start_autofs)
	{
	    string pkg = "autofs";
	    if (! IsPackageInstalled (pkg) &&
		! IsPackageInstalled ("autofs4"))
	    {
		install_packages = add (install_packages, pkg);
		// Translators: popup message part, ends with a newline
		message = message + _("The automounter package will be installed.\n");
	    }
	}

	return message;
    }

    /* ---------------------------------------------------------------- */

    /**
     * Set module data
     * @return void
     */
    global define void Set (map settings) ``{
	start = settings["start_nis"]:false;

	servers = settings["nis_servers"]:[];
	default_broadcast = settings["nis_broadcast"]:false;
	domain = settings["nis_domain"]:"";
	old_domain = domain;

	domain_by_dhcp_wanted = settings["nis_domain_by_dhcp"]:false;
	servers_by_dhcp_wanted = settings["nis_servers_by_dhcp"]:false;
	auto_mode = true;
	// we don't know what the state will be before Write, so restart it
	dhcp_restart = true;

	list other_domains = settings["nis_other_domains"]:[];
	foreach (map other_domain, other_domains, ``{
	    string d = other_domain["nis_domain"]:"";
	    list(string) s = other_domain["nis_servers"]:[];
	    boolean b = other_domain["nis_broadcast"]:false;
	    multidomain_servers = add (multidomain_servers, d, s);
	    multidomain_broadcast = add (multidomain_broadcast, d, b);
	});

	local_only = settings["nis_local_only"]:false;
	broken_server = settings["nis_broken_server"]:false;
	options = settings["nis_options"]:"";

	// autofs is not touched in Write if the map does not want it
	_autofs_allowed = haskey (settings, "start_autofs");
	_start_autofs = settings["start_autofs"]:false;
    }

    // TODO update the map keys
    // better still: link to a current interface description
    /**
     * Get all the NIS configuration from a map.
     * When called by nis_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	$["start": "domain": "servers":[...] ]
     * @return	success
     */
    global define boolean Import (map settings) ``{
	if (size (settings) == 0)
	{
	    //Provide defaults for autoinstallation editing:
	    //Leave empty.
	    old_domain = domain;
	    // enable _autofs_allowed
	    // Injecting it into the defaults for the GUI
	    // but leaving the check in Set makes it possible
	    // to delete the element manually from the xml profile
	    // and leave autofs untouched
	    settings["start_autofs"] = false;
	    Set(settings);
	    return true;
	}

	boolean missing = false;
	// "nis_domain" can be omitted if nis_domain_by_dhcp is true
	foreach (`k, ["start_nis"], ``{
	    if (! haskey (settings, k))
	    {
		y2error ("Missing at Import: '%1'.", k);
		missing = true;
	    }
	});
	if (missing)
	{
	    return false;
	}

	Set(settings);
	return true;
    }

    // TODO update the map keys
    // better still: link to a current interface description
    /**
     * Dump the NIS settings to a map, for autoinstallation use.
     * @return $["start":, "servers":[...], "domain":]
     */
    global define map Export () ``{
	list other_domains = maplist (string d, list s, multidomain_servers, ``{
	    return $[
		"nis_domain": d,
		"nis_servers": s,
		"nis_broadcast": multidomain_broadcast[d]:false,
		];
	});

	if (global_broadcast)
	{
	    y2error ("Attempt to export Nis::global_broadcast");
	}

	return $[
	    "start_nis": start,

	    "nis_servers": servers,
	    "nis_domain": domain,
	    "nis_broadcast": default_broadcast,

	    "nis_other_domains": other_domains,

	    "nis_domain_by_dhcp": domain_by_dhcp_wanted,
	    "nis_servers_by_dhcp": servers_by_dhcp_wanted,

	    "nis_local_only": local_only,
	    "nis_broken_server": broken_server,
	    "nis_options": options,

	    "start_autofs": _start_autofs,
	    ];
    }

    /**
     * @return Html formatted configuration summary
     */
    global define string Summary () ``{
	// TODO multidomain_servers, multidomain_broadcast
	// OK, a dumb mapping is possible, but wouldn't it be
	// too complicated to write by hand?
	string summary = "";
	string nc = Summary::NotConfigured ();

	// summary: Domain or servers are retrieved by the
	// Dynamic Host Configuration Protocol.
	// Will be placed after NIS Domain/NIS Servers instead of the
	// actual settings.
	string dhcp = _("by DHCP");

	// summary header
	summary = Summary::AddHeader(summary, _("NIS Client enabled"));
	// summary item: an option is turned on
	summary = Summary::AddLine(summary, (start) ? _("Yes") : nc);
	// summary header
	summary = Summary::AddHeader(summary, _("NIS Domain"));
	summary = Summary::AddLine(summary,
				   domain_by_dhcp_wanted ? dhcp :
				   ((domain != "") ? domain : nc));
	// summary header
	summary = Summary::AddHeader(summary, _("NIS Servers"));
	summary = Summary::AddLine(summary,
				   servers_by_dhcp_wanted ? dhcp :
				   ((servers !=[]) ? mergestring(servers,"<br>") : nc));
	// summary header
	summary = Summary::AddHeader(summary, _("Broadcast"));
	// summary item: an option is turned on
	summary = Summary::AddLine(summary, (default_broadcast) ? _("Yes") : nc);
	// TODO: a full list
	summary = summary + ListItem (_("Other domains"), multidomain_servers);
	// summary header
	summary = Summary::AddHeader(summary, _("Answer to local host only"));
	// summary item: an option is turned on
	summary = Summary::AddLine(summary, (local_only) ? _("Yes") : nc);
	// summary header
	summary = Summary::AddHeader(summary, _("Broken server"));
	// summary item: an option is turned on
	summary = Summary::AddLine(summary, (broken_server) ? _("Yes") : nc);
	// summary header
	summary = Summary::AddHeader(summary, _("ypbind options"));
	summary = Summary::AddLine(summary, (options!="") ? options : nc);
	// summary header
	summary = Summary::AddHeader(summary, _("Automounter enabled"));
	// summary item: an option is turned on
	summary = Summary::AddLine(summary, (_start_autofs) ? _("Yes") : nc);

	return summary;
    }

    // copied from Mail.ycp
    // replace with a custom list
    /**
     * Summarizes a list of data
     * @param title passed to Summary::AddHeader
     * @param value a list (of scalars, lists or maps)
     * @return Summary-formatted description
     */
    define string ListItem(string title, any value) ``{
	string summary = "";
	summary = Summary::AddHeader(summary, title);
	//enhancement BEGIN
	if (is (value, map))
	{
	    value = maplist (any k, any v, value, ``(k));
	}
	//enhancement END
	if (is(value,list) && size(value)>0) {
	    summary = Summary::OpenList(summary);
	    foreach (`d, value, ``{
		string entry = "";
		if (is(d,map) || is (d,list))
		    entry = sformat("%1 Entries configured", size(value));
		else
		    entry = d;

		summary = Summary::AddListItem(summary, entry);
	    });
	    summary = Summary::CloseList(summary);
	} else {
	    summary = Summary::AddLine(summary,Summary::NotConfigured ());
	}
	return summary;
    }

    /**
     * Reads a database entry from nsswitch_conf and returns it as a list
     * @param db eg. "passwd"
     * @return   eg. ["files", "nis"]
     */
    define list(string) ReadNssDb (string db) ``{
	string db_s = SCR::Read (add (.etc.nsswitch_conf, db));
	if (db_s == nil)
	{
	    db_s = "";
	}
	return filter (string s, splitstring (db_s, " \t"), ``(s != ""));
    }

    /**
     * Writes a database entry as a list to nsswitch_conf
     * @param db eg. "passwd"
     * @param entries eg. ["files", "nis"]
     * @return success?
     */
    define boolean WriteNssDb (string db, list(string) entries) ``{
	return SCR::Write (add (.etc.nsswitch_conf, db),
			   mergestring (entries, " "));
    }

    /**
     * Reads NIS settings from the SCR
     * @return success
     */
    global define boolean Read () ``{
	start = Runlevel::ServiceEnabled ("ypbind");

	servers = SCR::Read (.etc.yp_conf.servers);
	default_broadcast = SCR::Read (.etc.yp_conf.defaultbroadcast);
	multidomain_servers = SCR::Read (.etc.yp_conf.domainservers);
	multidomain_broadcast = SCR::Read (.etc.yp_conf.broadcast);

	map out = SCR::Execute (.target.bash_output, "/bin/ypdomainname");
	domain = deletechars (out["stdout"]:"", "\n");
	old_domain = domain;

	servers_by_dhcp_wanted = SCR::Read (
	    .sysconfig.dhcp.DHCLIENT_MODIFY_NIS_CONF) == "yes";
	domain_by_dhcp_wanted = SCR::Read (
	    .sysconfig.dhcp.DHCLIENT_SET_DOMAINNAME) == "yes";
	string di = "/var/lib/dhcpcd/dhcpcd-*.info";
	servers_by_dhcp_actual = servers_by_dhcp_wanted && SCR::Execute (
	    .target.bash, "/bin/grep -qs '^NISSERVERS' " + di) == 0;
	domain_by_dhcp_actual = domain_by_dhcp_wanted && SCR::Execute (
	    .target.bash, "/bin/grep -qs '^NISDOMAIN' " + di) == 0;

	local_only = SCR::Read (.sysconfig.ypbind.YPBIND_LOCAL_ONLY) == "yes";
	global_broadcast = SCR::Read (.sysconfig.ypbind.YPBIND_BROADCAST) == "yes";
	broken_server = SCR::Read (.sysconfig.ypbind.YPBIND_BROKEN_SERVER) == "yes";
	options = SCR::Read (.sysconfig.ypbind.YPBIND_OPTIONS);

	// install on demand
	_autofs_allowed = true;
	/*
	_autofs_allowed =
	    IsPackageInstalled ("autofs") ||
	    IsPackageInstalled ("autofs4");
	*/
	_start_autofs = _autofs_allowed && Runlevel::ServiceEnabled ("autofs");

	hosts_by_nis = contains (ReadNssDb ("hosts"), "nis");

	return true;
    }

    /**
     * Configures the name service switch for the user databases
     * according to chosen settings
     * @return success?
     */
    global define boolean WriteNssUsers () ``{
	list(string) dbs = ["passwd", "group", "shadow"];
	// Why bother with both compat and nis?
	// If there's no plus, we don't have to write passwd etc.
	// And it's supposed to be faster.
	boolean have_plus = HavePlus ();
	if (start)
	{
	    // watch out for failures :))
	    if (have_plus)
	    {
		// we want to switch to "compat"
		foreach (string db, dbs, ``{
		    // what if a db is not mentioned?
		    // We get [] meaning compat, so it's ok to make it explicit
		    list(string) db_l = ReadNssDb (db);

		    if (!contains (db_l, "compat"))
		    {
			// remove "files" and "nis", if there;
			db_l = filter (string s, db_l, ``(
					   s != "files" && s != "nis"));
			// put "compat" and the rest;
			db_l = prepend (db_l, "compat");
			WriteNssDb (db, db_l);
		    }
		});
		WritePluses ();
	    }
	    else // no plus - can add files nis
	    {
		foreach (string db, dbs, ``{
		    list(string) db_l = ReadNssDb (db);

		    if (!contains (db_l, "nis"))
		    {
			// remove "compat" if there;
			// put "files", "nis" and the rest
			db_l = filter (string s, db_l, ``(
					   s != "compat" && s != "files"));
			// put "nis", we know it's not there
			db_l = prepend (db_l, "nis");
			// put "files" - before nis
			db_l = prepend (db_l, "files");
			WriteNssDb (db, db_l);
		    }
		});
	    }
	}
	else // not start
	{
	    if (have_plus)
	    {
		// Do nothing - it is ok to leave the pluses in with compat
		// (if there's plus and nis, it's inconsistent -
		//  resolve manually)
	    }
	    else
	    {
		foreach (string db, dbs, ``{
		    list(string) db_l = ReadNssDb (db);

		    // remove "nis" if there;
		    db_l = filter (string s, db_l, ``(s != "nis"));
		    // if nothing left, put "files";
		    if (db_l == [])
		    {
			db_l = ["files"];
		    }
		    WriteNssDb (db, db_l);
		});
	    }
	}

	if (!SCR::Write (.etc.nsswitch_conf, nil))
	{
	    // error popup
	    Report::Error (sformat (_("Error writing file %1."),
				    "/etc/nsswitch.conf"));
	    return false;
	}
	return true;
    }

    /**
     * Configures the name service switch for autofs
     * according to chosen settings
     * @return success?
     */
    global define boolean WriteNssAutofs () ``{
	boolean ok = true;

	// nsswitch automount:
	// bracket options not allowed, order does not matter
	list(string) automount_l = ReadNssDb ("automount");
	boolean enabled = contains (automount_l, "nis");
	// enable it if it is not enabled yet and both services run
	if (start && _start_autofs && !enabled)
	{
	    automount_l = add (automount_l, "nis");
	    ok = WriteNssDb ("automount", automount_l);
	    ok = ok && SCR::Write (.etc.nsswitch_conf, nil);
	}
	// disable it if it is enabled and either service does not run
	else if (!(start && _start_autofs) && enabled)
	{
	    automount_l = filter (string s, automount_l, ``(s != "nis"));
	    ok = WriteNssDb ("automount", automount_l);
	    ok = ok && SCR::Write (.etc.nsswitch_conf, nil);
	}

	if (!ok)
	{
	    // error popup
	    Report::Error (sformat (_("Error writing file %1."),
				    "/etc/nsswitch.conf"));
	}
	return ok;
    }

    /**
     * Only write new configuration w/o starting any scripts
     * @return true on success
     */
    global define boolean WriteOnly()``{
	if (start)
	{
	    Runlevel::ServiceAdjust ("portmap", "enable");
	    Runlevel::ServiceAdjust ("ypbind", "enable");

	    if (!DomainByDhcpActual ())
	    {
		if (!SCR::Write (.etc.defaultdomain, domain))
		{
		    // error popup
		    Report::Error (sformat (_("Error writing file %1."),
					    "/etc/defaultdomain"));
		    return false;
		}
	    }
	    if (!ServersByDhcpActual ())
	    {
		SCR::Write (.etc.yp_conf.servers, servers);
		SCR::Write (.etc.yp_conf.defaultbroadcast, default_broadcast);
		SCR::Write (.etc.yp_conf.domainservers, multidomain_servers);
		SCR::Write (.etc.yp_conf.broadcast, multidomain_broadcast);
		if (! SCR::Write (.etc.yp_conf, nil))
		{
		    // error popup
		    Report::Error (sformat (_("Error writing file %1."),
					    "/etc/yp.conf"));
		    return false;
		}
	    }
	    SCR::Write (.sysconfig.ypbind.YPBIND_LOCAL_ONLY, local_only? "yes":"no");
	    SCR::Write (.sysconfig.ypbind.YPBIND_BROADCAST, global_broadcast? "yes":"no");
	    SCR::Write (.sysconfig.ypbind.YPBIND_BROKEN_SERVER, broken_server? "yes":"no");
	    SCR::Write (.sysconfig.ypbind.YPBIND_OPTIONS, options);
	    if (! SCR::Write (.sysconfig.ypbind, nil))
	    {
		// error popup
		Report::Error (sformat (_("Error writing file %1."),
					"/etc/sysconfig/ypbind"));
		return false;
	    }

	    SCR::Write (.sysconfig.dhcp.DHCLIENT_SET_DOMAINNAME,
			domain_by_dhcp_wanted? "yes":"no");
	    SCR::Write (.sysconfig.dhcp.DHCLIENT_MODIFY_NIS_CONF,
			servers_by_dhcp_wanted? "yes":"no");
	    if (! SCR::Write (.sysconfig.dhcp, nil))
	    {
		// error popup
		Report::Error (sformat (_("Error writing file %1."),
					"/etc/sysconfig/network/dhcp"));
		return false;
	    }
	}
	else
	{
	    Runlevel::ServiceAdjust ("ypbind", "disable");
	}

	// TODO do as much as possible if one thing fails
	// especially WRT nis/autofs independence
	WriteNssUsers ();

	if (true) // autofs no longer depends on nis, #19769
	{
	    if (_autofs_allowed)
	    {
		boolean ok = WriteNssAutofs ();
		if (!ok)
		{
		    return false;
		}

		if (_start_autofs)
		{
		    Runlevel::ServiceAdjust ("autofs", "enable");
		}
		else
		{
		    Runlevel::ServiceAdjust ("autofs", "disable");
		}
	    }
	}
	return true;
    }

    /**
     * Saves NIS configuration.
     * @return true on success
     */
    global define boolean Write () ``{
	if (!WriteOnly ())
	{
	    return false;
	}

	if (dhcp_restart)
	{
	    // Restart the dhcp client, if it is running, to parse the changed
	    // options
	    Runlevel::RunInitScript ("network", "restart-all-dhcp-clients");
	}

	Runlevel::RunInitScript ("ypbind", "stop");

	if (start)
	{
	    if (Runlevel::ServiceStatus ("portmap") != 0 )
	    {
		// portmap must not be started if it is running already (see bug # 9999)
		if (Runlevel::RunInitScript ("portmap", "start") != 0)
		{
		    // error popup message
		    Report::Error (_("Error while running portmapper."));
		    return false;
		}
	    }
	    sleep(1000);	// workaround for bug #10428, ypbind restart

	    map out = SCR::Execute (.target.bash_output, "/etc/init.d/ypbind start", $["TERM": "raw"]);
	    if (out["exit"]:1 == 0)
	    {
		YpbindErrors = "";
	    }
	    else
	    {
		YpbindErrors = out["stdout"]:"internal error";
		// error popup message
		Report::Error (_("Error while running ypclient."));
		return false;
	    }

	    // only test for a server if domain not changed
	    if (! domain_changed)
	    {
		if (SCR::Execute(.target.bash, "/usr/bin/ypwhich >/dev/null") != 0)
		{
		    // error popup message
		    Report::Error (_("NIS server not found."));
		    return false;
		}
	    }
	}

	// if the name service cache daemon is running, restart it
	if (Runlevel::ServiceStatus ("nscd") == 0) {
	    Runlevel::RunInitScript ("nscd", "restart");
	}

	if (true) // autofs no longer depends on nis, #19769
	{
	    if (_autofs_allowed)
	    {
		Runlevel::RunInitScript ("autofs", "stop");

		if (_start_autofs)
		{
		    Runlevel::RunInitScript ("autofs", "start");
		}
	    }
	}
	return true;
    }

    /**
     * @param file a pathname
     * @return is there a nis inclusion?
     */
    define boolean HasPlus (string file) ``{
	// does the file have a plus?
	return (0 == SCR::Execute (.target.bash, "/usr/bin/grep -q '^[+-]' " + file));
    }

    /**
     * Do we need compat? Is there a plus in any of the user databases?
     * @return true/false
     */
    define boolean HavePlus () ``{
	list(string) files = [
	    "/etc/passwd",
	    "/etc/shadow",
	    "/etc/group",
	    ];
	// find a file having a plus
	return nil != find (string file, files, ``( HasPlus (file) ));
    }

    /**
     * Add "+" lines to system files so that NIS entries get merged in.
     * (Formerly this was done in SuSEconfig.ypclient)
     * @return success?
     */
    define boolean WritePluses () ``{
	list(string) files = ["passwd", "shadow", "group"];
	//don't forget a newline
	map what_to_write = $[
	    "passwd":	"+::::::",
	    "group":	"+:::",
	    "shadow":	"+",
	    ];
	foreach (string f, files, ``{
	    if (! WritePlusesTo (sformat ("/etc/%1", f), what_to_write[f]:""))
	    {
		return false;
	    }
	});
	return true;
    }

    /**
     * If a file does not contain a NIS entry, add it.
     * @param	file	pathname
     * @param	what	a "+" line without a '\n'
     * @return success?
     */
    define boolean WritePlusesTo (string file, string what) ``{
	if (!HasPlus (file))
	{
	    // not there, add it
	    // TODO: backup?
	    if (SCR::Execute (.target.bash, sformat ("/bin/echo '%1' >> %2", what, file)) != 0)
	    {
		// error popup
		Report::Error (sformat (_("Error writing file %1."), file));
		return false;
	    }
	}
	return true;
    }
}
