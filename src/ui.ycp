/**
 * File:
 *   include/nis/ui.ycp
 *
 * Package:
 *   Configuration of NIS
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{
    textdomain "nis";

    import "Wizard";
    import "Nis";
    import "Mode";
    import "Require";
    import "Label";
    import "Popup";
    import "Autologin";

    include "wizard/sequencer.ycp";

    /**
     * A Wizard Sequencer helper
     * @return	`next
     */
    define symbol JustNext () ``{
	return `next;
    }

    /*const*/ string broadcast_help =
	// Translators: network broadcast address
	_("<p>The <b>Broadcast</b> option enables searching
in the local network to find a server after the specified servers
fail to respond. It is a security risk.</p>
");

    /*const*/ string dhcp_help =
	// Translators: help text
	// DHCP = Dynamic host configuration protocol
	_("<p>If you are using <b>DHCP</b> and the server provides the NIS domain name or servers, you can enable their use here. DHCP itself can be set up in the network module.</p>");

    /*const*/ string expert_help =
	// Translators: short for Expert settings
	_("<p><b>Expert</b> gives access to some
less frequently used settings.</p>
");

    /**
     * The dialog that appears when the [Abort] button is pressed.
     * @param touched data modified?
     * @return `abort if user really wants to abort, `back otherwise
     */
    define boolean ReallyAbort (boolean touched) ``{

	return (!Mode::cont)
	    ? Popup::ReallyAbort (touched)
	    : Popup::ConfirmAbort (`incomplete);
    }

    /**
     * Pop up a warning if dhcp does not provide nis configuration
     */
    define void WarnIfDhcpNotServed () ``{
	if (!Nis::dhcp_possible)
	{
	    // Translators: warning popup
	    Popup::Warning (_("NIS configuration is not currently provided by DHCP.
Change the DHCP server configuration to provide it.
"));
	}
    }

    /**
     * Let the user choose some of a list of items
     * @param title	selectionbox title
     * @param items	a list of items
     * @return		items or nil on cancel
     */
    define list<string> ChooseItems (string title, list<string> items) ``{
	list<term> msb_items = maplist (string entry, items,
					 ``( `item (`id (entry), entry)));
	UI::OpenDialog (
	    `VBox (
		`HSpacing (40),
		`HBox (
		    `MultiSelectionBox (`id (`items), title, msb_items),
		    `VSpacing(10)
		    ),
		`HBox (
		    // pushbutton label
		    // Select all items (in this case NIS servers) of a list
		    `PushButton (`id (`all), _("Select &All")),
		    // pushbutton label
		    // Deselect all items (in this case NIS servers) of a list
		    `PushButton (`id (`none), _("Select &None"))
		    ),
		`HBox (
		    `PushButton (`id (`ok), `opt (`default, `key_F10),
				 Label::OKButton ()),
		    `PushButton (`id (`cancel), `opt (`key_F9),
				 Label::CancelButton())
		    )
		));
	UI::SetFocus (`id (`items));
	any ret = nil;
	do
	{
	    ret = UI::UserInput();
	    if (ret == `all)
	    {
		UI::ChangeWidget (`id (`items), `SelectedItems, items);
	    }
	    else if (ret == `none)
	    {
		UI::ChangeWidget (`id (`items), `SelectedItems, []);
	    }
	}
	while (ret != `cancel && ret != `ok);

	if (ret == `ok)
	{
	    items = (list<string>) UI::QueryWidget (`id (`items), `SelectedItems);
	}
	else
	{
	    items = nil;
	}
	UI::CloseDialog();

	return items;
    }

    /**
     * A cache of NIS servers found on the LAN for each domain.
     * @see SelectNisServers
     */
    map found_servers = $[]; // map <string, list <string> >

    /**
     * Scan the network for NIS servers and let the user select among them.
     * @param domain which domain
     * @return space separated list of servers or ""
     */
    define string SelectNisServers (string domain) ``{
	Wizard::SetScreenShotName ("nis-client-2a1-servers");
	if (Mode::screen_shot)
	{
	    found_servers[domain] = ["nis.example.com", "10.42.1.1", "10.42.1.2"];
	}

	if (!haskey (found_servers, domain))
	{
	    // popup window
	    // LAN: local area network
	    UI::OpenDialog (`Label (sformat (_("Scanning for NIS servers in domain %1 on this LAN..."), domain)));
	    found_servers[domain] = SCR::Read (add (.net.ypserv.find, domain));
	    UI::CloseDialog ();
	    if (found_servers[domain]:nil == nil)
	    {
		found_servers[domain] = ["internal-error"];
	    }
	}

	list <string> selected_servers =
	    // selection box label
	    ChooseItems (sformat (_("&NIS Servers in domain %1"), domain),
			 found_servers[domain]:[]);
	y2milestone ("selected_servers: %1", selected_servers);
	if (selected_servers == nil)
	{
	    selected_servers = [];
	}
	Wizard::RestoreScreenShotName ();
	return mergestring (selected_servers, " ");
    }


    /**
     * The simple dialog
     * @return	`back, `abort, `next, `multiple or `expert
     */
    define symbol NisDialog () ``{
	Wizard::SetScreenShotName ("nis-client-2a-single");

	// help text 1/3
	string help_text = _("<p>Enter your NIS domain (e.g, foo.com)
 and the NIS server's address (e.g., nis.foo.com or 10.20.1.1).</p>");

	// help text 2/3
	help_text = help_text + _("<p>Specify multiple servers
by separating their addresses with spaces.</p>
");

	help_text = help_text + broadcast_help;

	help_text = help_text + dhcp_help;

	help_text = help_text + expert_help;

	// help text 2/3
	help_text = help_text + _("<p>If you need to access
<b>Multiple domains</b>, use the button to switch to a detailed dialog.</p>");

	boolean dhcp_wanted = Nis::dhcp_wanted;
	string domain  = Nis::GetDomain ();
	string servers = Nis::GetServers ();

	// In this simple case, let's discard the distinction.
	boolean default_broadcast =
	    Nis::default_broadcast || Nis::global_broadcast;

	term con = nil;
	term nis_frame =
	    // frame label
	    `Frame (_("NIS client"),
		    `VBox (`VSpacing (0.2),


			   `RadioButtonGroup (
			       `id (`dhcpg),
			       `VBox (
				   // radio button label
				   `Left (`RadioButton (`id (`dhcpyes), `opt (`notify), _("&Automatic Setup (via DHCP)"), dhcp_wanted)),
				   // radio button label
				   `Left (`RadioButton (`id (`dhcpno), `opt (`notify), _("&Static Setup"), !dhcp_wanted))
				   )),


			   // text entry label
			   `TextEntry (`id (`domain), _("NIS &domain"), domain),
			   `VSpacing (0.2),
			   // text entry label
			   `TextEntry (`id (`servers), _("&Addresses of NIS servers"), servers),
			   `HBox (
			       // check box label
			       `Left (`CheckBox (`id (`broadcast), `opt (`notify), _("Br&oadcast"), default_broadcast)),
			       // pushbutton label, find nis servers
			       // Shortcut must not conflict with Finish and Next (#29960)
			       `Right (`PushButton (`id (`find), _("Fin&d")))
			       ),
			   `VSpacing (0.2),
			   `HBox (
			       `PushButton (`id (`expert), `opt (`key_F7),
					    // button label
					    // (short for Expert settings)
					    _("&Expert ...")),
			       `PushButton (`id (`multiple), `opt (`key_F2),
					    // button label
					    _("&Multiple domains >>"))
			       ),
			   `VSpacing (0.2)
			)
		);

	con = `HVSquash (nis_frame);

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Configuration of NIS client"), con, help_text,
	    Label::BackButton (), Mode::cont? Label::NextButton():Label::FinishButton ());
	if (Mode::cont) Wizard::ReplaceAbortButton (
	    `PushButton(`id(`abort), Label::AbortInstallationButton()));

	any result = nil;
	repeat
	{
	    dhcp_wanted = (symbol) UI::QueryWidget (`id (`dhcpg), `CurrentButton) == `dhcpyes;
	    UI::ChangeWidget (`id (`domain), `Enabled, !dhcp_wanted);
	    UI::ChangeWidget (`id (`servers), `Enabled, !dhcp_wanted);
	    UI::ChangeWidget (`id (`broadcast), `Enabled, !dhcp_wanted);
	    UI::ChangeWidget (`id (`find), `Enabled, !dhcp_wanted);
	    UI::ChangeWidget (`id (`multiple), `Enabled, !dhcp_wanted);

	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }

	    if (result == `dhcpyes)
	    {
		WarnIfDhcpNotServed ();
	    }
	    else if (result == `find)
	    {
		domain =  (string) UI::QueryWidget (`id (`domain), `Value);
		if (domain == "")
		{
		    // Message popup. The user wants to Find servers
		    // but the domain is unknown.
		    Popup::Message (_("Finding servers works only when the domain is known."));
		    UI::SetFocus (`id (`domain));
		}
		else
		{
		    string servers = SelectNisServers (domain);
		    if (servers != "")
		    {
			UI::ChangeWidget (`id (`servers), `Value, servers);
		    }
		}
	    }
	    else if (contains ([`next, `expert, `multiple], result))
	    {
		domain = (string) UI::QueryWidget (`id (`domain), `Value);
		servers = (string) UI::QueryWidget (`id (`servers), `Value);
		default_broadcast = (boolean) UI::QueryWidget (`id (`broadcast), `Value);

		if (!dhcp_wanted &&
		    !Nis::check_nisdomainname (domain))
		{
		    UI::SetFocus (`id (`domain));
		    Popup::Error (Nis::valid_nisdomainname ());
		    result = nil;
		    continue;
		}

		list temp_ad = filter (string a, splitstring (servers, " "),
				       ``(a != ""));
		if (!dhcp_wanted && !default_broadcast &&
		    (size (temp_ad) == 0 ||
		     find (string a, temp_ad,
			   ``(!Nis::check_address_nis (a))) != nil))
		{
		    UI::SetFocus (`id (`servers));
		    Popup::Message (Nis::valid_address_nis ());
		    result = nil;
		    continue;
		}
	    }
	}
	until (result == `back || result == `next || result == `expert ||
	       result == `multiple ||
	       (result == `abort && ReallyAbort (Nis::touched)));

	if (contains ([`next, `expert, `multiple], result))
	{
	    Nis::dhcp_restart = Nis::dhcp_restart ||
		(Nis::dhcp_wanted != dhcp_wanted);
	    Nis::Touch (Nis::dhcp_restart);
	    Nis::dhcp_wanted = dhcp_wanted;

	    Nis::SetDomain (domain);
	    Nis::SetServers (servers);
	    Nis::Touch (Nis::default_broadcast != default_broadcast);
	    Nis::default_broadcast = default_broadcast;
	    Nis::Touch (Nis::global_broadcast != false);
	    Nis::global_broadcast = false;
	}

	Wizard::RestoreScreenShotName ();
	return (symbol) result;
    }


    /**
     * The expert dialog
     * @return	`back, `abort or `next
     */
    define symbol ExpertDialog () ``{
	Wizard::SetScreenShotName ("nis-client-2c-expert");

	// help text 1/4
	string help_text = _("<p>Normally, it is possible for any host to query which server a client is using. <b>Answer to the local host only</b> prevents it.</p>");

	// help text 2/4
	// Check, ie. turn on a check box
	help_text = help_text + _("<p>Check <b>Broken server</b> if answers from servers running on an unprivileged port should be accepted. It is a security risk and it is better to replace such a server.</p>");

	// help text 3/4
	help_text = help_text + _("<p>See <b>man ypbind</b> for details on other options.</p>");

	boolean local_only = Nis::local_only;
	boolean broken_server = Nis::broken_server;
	string options = Nis::options;

	term contents =
	    `HSquash (`VBox (
		`Frame (
		    // frame label
		    _("Expert settings"),
		    `VBox (
			`VSpacing (0.2),
			// check box label
			`Left (`CheckBox (`id (`local_only), _("Answer to the &local host only"), local_only)),
			// check box label
			`Left (`CheckBox (`id (`broken_server), _("Br&oken server"), broken_server)),
			`VSpacing (0.2),
			// text entry label
			// ypbind is the daemon name
			`TextEntry (`id (`options), _("Other &ypbind options"), options),
			`VSpacing (0.2)
			)
		    ),
		`Empty ()
		));

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Expert settings"), contents, help_text,
	    Label::BackButton (), Label::OKButton ());
	if (Mode::cont) Wizard::ReplaceAbortButton (
	    `PushButton(`id(`abort), Label::AbortInstallationButton()));

	any result = nil;
	repeat
	{
	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }

	    if (result == `next)
	    {
		local_only =  (boolean) UI::QueryWidget (`id (`local_only), `Value);
		broken_server = (boolean) UI::QueryWidget (`id (`broken_server), `Value);
		// TODO: disallow " in options
		options = (string) UI::QueryWidget (`id (`options), `Value);

/*		if (false && some_error)
		{
		    // error popup label
		    Popup::Message (_("The domain name is not correct."));
		    result = nil;
		}*/
	    }
	}
	until (result == `back || result == `next ||
	       (result == `abort && ReallyAbort (Nis::touched)));

	if (result == `next)
	{
	    Nis::Touch (Nis::local_only != local_only);
	    Nis::local_only = local_only;
	    Nis::Touch (Nis::broken_server != broken_server);
	    Nis::broken_server = broken_server;
	    Nis::Touch (Nis::options != options);
	    Nis::options = options;
	}

	Wizard::RestoreScreenShotName ();
	return (symbol) result;
    }

    /**
     * @param default_d the default domain
     * @return "Default: default_d"
     */
    define string DefaultCell (string default_d) ``{
	// Translators: the default NIS domain
	return sformat (_("Default: %1"), default_d);
    }

    string check_g = nil;
    /**
     * Constructs items for the domain table
     * @param	default_d	the default domain
     * @param	all_servers	map of @ref server_sp
     * @return a list of items
     * @see Nis#multidomain_servers TODO
     */
    define list DomainTableItems (string default_d, map all_servers) ``{
	if (check_g == nil)
	{
	    check_g = UI::Glyph (`CheckMark);
	}
	// maps are sorted, so the default domain, "", comes first
	return maplist (string d, list server_sp, all_servers, ``(
			    `item (
				`id (d),
				(d == "")? DefaultCell (default_d): d,
				// this would be a priority example x ]:
				(server_sp[1]:false)? check_g: "",
				mergestring (server_sp[0]:[], ", ")
				)
			    ));
    }

    /**
     * @param	default_d	the default domain
     * @param	all_servers show these items
     * @param	d	the selected item
     */
    define void UpdateDomainTable (string default_d, map all_servers,
					  string d) ``{
	UI::ChangeWidget (`id (`domains), `Items,
			  DomainTableItems (default_d, all_servers));
	UI::ChangeWidget (`id (`domains), `CurrentItem, d);
    }

    /**
     * @param	m	a map
     * @return		keys of the map
     */
    define list mapkeys (map m) ``{
	return maplist (any k, any v, m, ``( k ));
    }

    /**
     * @tuple server_sp
     * 0 list(string)	server list
     * 1 boolean	broadcast
     */

    /**
     * Add/Edit a domain, including its name and servers
     * @param	init		currently selected domain: nil=add, ""=default
     * @param	default_d	the default domain
     * @param	server_sp	@ref server_sp
     * @param	existing	existing domains
     * @return [name, [ [server1, server2], broadcast? ]]
     */
    define list DomainPopup (string init, string default_d,
				    list server_sp, list<string> existing) ``{
	Wizard::SetScreenShotName ("nis-client-2b1-domain");

	string domain = (init == nil)? "": ((init == "") ? default_d: init);
	list<string> servers = server_sp[0]:[];
	string servers_s = mergestring (servers, "\n");
	boolean broadcast = server_sp[1]:false;

	term t_servers =
	    `VBox (
		`MultiLineEdit(`id (`servers),
			       // Translators: multilineedit label
			       // comma: ","
			       _("&Servers (separated by spaces or commas)"),
			       servers_s),
		`HBox (
		    `CheckBox (`id (`local_broadcast),
			       // checkbox label
			       _("&Broadcast"), broadcast),
		    // pushbutton label, find nis servers
		    // Shortcut must not conflict with Finish and Next (#29960)
		    `PushButton (`id (`find), _("Fin&d"))
		    ),
		`Empty ()
		);

	term contents =
	    `HBox(
		`HSpacing(1),
		`VBox(
		    `VSpacing(0.2),
		    // Translators: popup dialog heading
		    `Heading (_("Domain Settings")),
		    // Add a domain, Adding a domain? Edit...
		    // Translators: text entry label
		    `Left (`TextEntry (`id (`domain), _("&Domain name"), domain)),
		    `VSpacing(0.5),
		    t_servers,
		    `VSpacing(0.2),
		    `HBox (`PushButton (`id (`ok), `opt (`default, `key_F10),
					Label::OKButton ()),
			   `PushButton (`id (`cancel), `opt (`key_F9),
					Label::CancelButton ())),
		    `VSpacing(0.2)
		    ),
		`HSpacing(1)
		);

	UI::OpenDialog (`opt(`decorated), contents);
	UI::SetFocus (`id (`domain));

	any ui = nil;
	while (true)
	{
	    ui = UI::UserInput ();
	    if (ui == `cancel)
	    {
		break;
	    }
	    else if (ui == `find)
	    {
		domain = (string) UI::QueryWidget (`id (`domain), `Value);
		if (domain == "")
		{
		    // Message popup. The user wants to Find servers
		    // but the domain is unknown.
		    Popup::Message (_("Finding servers works only when the domain is known."));
		    UI::SetFocus (`id (`domain));
		}
		else
		{
		    string servers = SelectNisServers (domain);
		    if (servers != "")
		    {
			UI::ChangeWidget (`id (`servers), `Value, servers);
		    }
		}
	    }
	    else if (ui == `ok)
	    {
		// Input validation
		// all querywidgets done now for consistency
		domain = (string) UI::QueryWidget (`id (`domain), `Value);
		servers_s = (string) UI::QueryWidget (`id (`servers), `Value);
		broadcast = (boolean) UI::QueryWidget (`id (`local_broadcast), `Value);

		servers = splitstring (servers_s, ", \n");
		servers = filter (string s, servers, ``( s != "" ));
		string bad_server = (string) find (string s, servers, ``(
					      !Nis::check_address_nis (s)
					      ));

		if (!Nis::check_nisdomainname (domain)) //also disallows ""
		{
		    UI::SetFocus (`id (`domain));
		    Popup::Error (Nis::valid_nisdomainname ());
		}
		else if (init != "" && domain != init &&
			 contains (existing, domain))
		{
		    UI::SetFocus (`id (`domain));
		    // Translators: error message
		    Popup::Error (_("This domain is already defined."));
		}
		else if (bad_server != nil)
		{
		    UI::SetFocus (`id (`servers));
		    string msg = sformat (
			// Translators: error message
			_("The format of server address '%1' is not correct."), bad_server);
		    Popup::Error (msg + "\n\n" + Nis::valid_address_nis ());
		}
		else
		{
		    // all checks OK, break the input loop
		    break;
		}
	    }
	}

	UI::CloseDialog ();
	Wizard::RestoreScreenShotName ();
	return (ui == `ok)? [domain, [servers, broadcast]] : nil;
    }

    /**
     * The servers dialog
     * @return	`back, `abort or `next
     */
    define symbol MultipleDialog () ``{
	Wizard::SetScreenShotName ("nis-client-2b-multiple");

	boolean dhcp_wanted = Nis::dhcp_wanted;
	// variable naming: _d means _domain, _s means _server
	string default_d = Nis::GetDomain ();
	boolean global_broadcast = Nis::global_broadcast;
	map all_servers = mapmap (string d, list s, Nis::multidomain_servers,
				  ``( $[d: [s, Nis::multidomain_broadcast[d]:false]] ));
	all_servers = add (all_servers, "",
			   [Nis::servers, Nis::default_broadcast]);

	boolean global_broadcast_allowed = global_broadcast;

	// help text
	string help_text = _("<p>Specify the servers for multiple domains and select the default domain.</p>");

	// help text
	help_text = help_text + broadcast_help;

	if (global_broadcast_allowed)
	{
	    // help text
	    // only shown if a deprecated advanced option (%1) is used.
	    help_text = help_text + sformat (_("<p>The broadcast option (%1) was made obsolete
by the <tt>broadcast</tt> keyword in <tt>/etc/yp.conf</tt>.
This check box only appears if it is turned on.</p>
"),
					     "<tt>ypbind -broadcast</tt>");
	}

	help_text = help_text + dhcp_help;

	help_text = help_text + expert_help;

	// help text
	help_text = help_text + _("<p>If you do not need multiple domains, use <b>Single domain</b> to switch to a simpler dialog.</p>");

	// "" means the default domain
	string current_d = "";

	// build the dialog contents
	term multiple =
	    `Frame (
		// frame label
		`id (`multiple), _("Multiple domains"),
		`VBox (
		    `VSpacing (0.2),
		    `Table (
			`id (`domains),
			`opt (`notify, `immediate),
			`header (
			    // table header
			    _("Domain"),
			    // table header
			    `Center (_("Broadcast")),
			    // table header
			    _("Servers")),
			DomainTableItems (default_d, all_servers)
			),
		    `HBox (
			// button label
			`PushButton (`id (`add_d), `opt (`key_F3), _("&Add")),
			// button label
			`PushButton (`id (`edit_d), `opt (`key_F4), _("E&dit")),
			// button label
			`PushButton (`id (`del_d), `opt (`key_F5), _("De&lete"))
			),
		    `VSpacing (0.2)
		    )
		);

	term global_broadcast_t = `Empty ();
	if (global_broadcast_allowed)
	{
	    global_broadcast_t = `CheckBox (
		`id (`global_broadcast), `opt (`notify),
		// check box label
		_("&Global broadcast"), global_broadcast
		);
	}

	term nis_vbox =
	    `VBox (`VSpacing (0.2),


			   `RadioButtonGroup (
			       `id (`dhcpg),
			       `VBox (
				   // radio button label
				   `Left (`RadioButton (`id (`dhcpyes), `opt (`notify), _("&Automatic Setup (via DHCP)"), dhcp_wanted)),
				   // radio button label
				   `Left (`RadioButton (`id (`dhcpno), `opt (`notify), _("&Static Setup"), !dhcp_wanted))
				   )),


		   `TextEntry (`id (`domain), `opt (`notify),
		   // text entry label
			       _("Default NIS do&main"), default_d),
		   `VSpacing (0.5),
		   `Left (global_broadcast_t),
		   multiple,
		   `VSpacing (0.2),
		   `HBox (
		       `PushButton (`id (`expert), `opt (`key_F7),
				    // button label
				    // (short for Expert settings)
				    _("&Expert ...")),
		       `PushButton (`id (`single), `opt (`key_F2),
				    // button label
				    _("&Single domain <<"))
		       ),
		   `VSpacing (0.2)
		);

	term nis_frame =
	    // frame label
	    `Frame (_("NIS client"), nis_vbox);

	term contents = nis_vbox;

	Wizard::SetContentsButtons (
	    sformat ("%1 - %2",
		     // dialog title
		     _("Configuration of NIS client"),
		     // dialog subtitle
		     _("Multiple domains")), contents, help_text,
	    Label::BackButton (), Mode::cont? Label::NextButton():Label::FinishButton ());
	if (Mode::cont) Wizard::ReplaceAbortButton (
	    `PushButton(`id(`abort), Label::AbortInstallationButton()));

	//UI::ChangeWidget (`id (`domains), `CurrentItem, current_d);

	any result = nil;
	// preselect an item
	// there is always the first item - the default domain
	UI::ChangeWidget (`id (`domains), `CurrentItem, "");

	while (true)
	{
	    dhcp_wanted = (symbol) UI::QueryWidget (`id (`dhcpg), `CurrentButton) == `dhcpyes;
	    current_d = (string) UI::QueryWidget (`id (`domains), `CurrentItem);
	    boolean any_d = current_d != nil;

	    UI::ChangeWidget (`id (`edit_d), `Enabled, any_d);
	    // deleting the defalut domain
	    // actually deletes only the server list
	    UI::ChangeWidget (`id (`del_d), `Enabled, any_d
			      /*&& current_d !=""*/);

	    UI::ChangeWidget (`id (`domain), `Enabled, !dhcp_wanted);
	    UI::ChangeWidget (`id (`multiple), `Enabled, !dhcp_wanted && !global_broadcast);
	    UI::ChangeWidget (`id (`single), `Enabled, !dhcp_wanted);

	    // Kludge, because a `Table still does not have a shortcut.
	    // exclude textentry-notify
	    if (result != `domain)
	    {
		UI::SetFocus (`id (`domains));
	    }

	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }

	    // only query if the widget is there
	    global_broadcast = global_broadcast_allowed &&
		(boolean) UI::QueryWidget (`id (`global_broadcast), `Value);

	    if (result == `domain)
	    {
		default_d = (string) UI::QueryWidget (`id (`domain), `Value);
		// update the Default: item
		UI::ChangeWidget (`id (`domains), `Item ("", 0),
				  DefaultCell (default_d));
	    }

	    // switch
	    if (result == `add_d)
	    {
		list name_servers = DomainPopup (nil, default_d, [[], false], (list<string>)mapkeys (all_servers));
		if (name_servers != nil)
		{
		    string d = (string) name_servers[0]:nil;
		    list s_sp = name_servers[1]:[];
		    all_servers = add (all_servers, d, s_sp);
		    // show these items, d selected
		    UpdateDomainTable (default_d, all_servers, d);
		}
	    }
	    else if (result == `edit_d)
	    {
		string d0 = (string) UI::QueryWidget (`id (`domains), `CurrentItem);

		if (d0 != nil)
		{
		    // editing the default domain is a special case
		    list name_servers = DomainPopup (d0, default_d,
						     all_servers[d0]:[],
						     (list<string>) mapkeys (all_servers));
		    if (name_servers != nil)
		    {
			string d = (string) name_servers[0]:nil;
			list s_sp = name_servers[1]:[];
			string newkey = (d0=="")? "": d;
			all_servers = mapmap (string k, list v, all_servers,``(
						  (k == d0) ?
						  $[ newkey: s_sp ] :
						  $[ k: v]
						  ));
			// update the default domain box
			if (d0 == "")
			{
			    default_d = d;
			    UI::ChangeWidget (`id (`domain),`Value, default_d);
			}
			// show these items, d selected
			// TODO: if it flickers,
			//  only replace the old line by a new one
			UpdateDomainTable (default_d, all_servers, newkey);
		    }
		}
	    }
	    else if (result == `del_d)
	    {
		string d0 = (string) UI::QueryWidget (`id (`domains), `CurrentItem);
		if (d0 == "")
		{
		    Wizard::SetScreenShotName ("nis-client-2b-del-dfl");
		    // do not delete the default domain, just the servers
		    // Translators: a yes-no popup
		    if (Popup::YesNo (_("Really delete the server list
for the default domain?")))
		    {
			all_servers = add (all_servers, "", [[], false]);
		    }
		    Wizard::RestoreScreenShotName ();
		    // show these items, the default domain selected
		    UpdateDomainTable (default_d, all_servers, "");
		}
		else if (d0 != nil)
		{
		    Wizard::SetScreenShotName ("nis-client-2b-del-dom");
		    // Translators: a yes-no popup
		    if (Popup::YesNo (_("Really delete this domain?")))
		    {
			all_servers = filter (string k, list v,
					      all_servers, ``(k != d0));
		    }
		    Wizard::RestoreScreenShotName ();
		    // show these items, the default domain selected
		    UpdateDomainTable (default_d, all_servers, "");
		}
	    }
	    else if (result == `dhcpyes)
	    {
		WarnIfDhcpNotServed ();
	    }
	    else if (contains ([`next, `expert, `single], result))
	    {
		// Input validation
		default_d = (string) UI::QueryWidget (`id (`domain), `Value);

		if (!dhcp_wanted &&
		    !Nis::check_nisdomainname (default_d))
		{
		    UI::SetFocus (`id (`domain));
		    Wizard::SetScreenShotName ("nis-client-2b1-err");
		    Popup::Error (Nis::valid_nisdomainname ());
		    Wizard::RestoreScreenShotName ();
		}
		else
		{
		    // all checks OK, break the input loop
		    // Warn about discarding when `single
		    //  or warn before checking?
		    if (result != `single ||
			size (all_servers) <= 1 ||
			Popup::ContinueCancel(
// Translators: Continue/Cancel popup
_("The settings for all domains except
the default domain will be lost.")))
		    {
			break;
		    }
		}
	    }
	    else if (result == `back || (result == `abort &&
					 ReallyAbort (Nis::touched)))
	    {
		break;
	    }
	}

	if (contains ([`next, `expert, `single], result))
	{
	    Nis::dhcp_restart = Nis::dhcp_restart ||
		(Nis::dhcp_wanted != dhcp_wanted);
	    Nis::Touch (Nis::dhcp_restart);
	    Nis::dhcp_wanted = dhcp_wanted;

	    Nis::SetDomain (default_d);
	    Nis::Touch (Nis::global_broadcast != global_broadcast);
	    Nis::global_broadcast = global_broadcast;

	    map only_servers = mapmap (string d, list v, all_servers, ``(
					   $[d: v[0]:[]]
					   ));
	    list<string> servers = only_servers[""]:[];
	    boolean default_broadcast = nil;
	    map multidomain_servers = nil;
	    map multidomain_broadcast = nil;
	    map slpdomain = nil;
	    if (result == `single)
	    {
		//TODO default_broadcast
		default_broadcast = false;
		multidomain_servers = $[];
		multidomain_broadcast = $[];
		slpdomain = $[];
	    }
	    else
	    {
		map only_broadcast = mapmap (string d, list v, all_servers, ``(
						 $[d: v[1]:false]
						 ));
		default_broadcast = only_broadcast[""]:false;
		multidomain_servers = filter (string d, list v,
					      only_servers, ``( d != "") );
		multidomain_broadcast = filter (string d, boolean v,
						only_broadcast, ``( d != "") );
	    }
	    Nis::Touch (Nis::servers != servers);
	    Nis::servers = servers;
	    Nis::Touch (Nis::default_broadcast != default_broadcast);
	    Nis::default_broadcast = default_broadcast;
	    Nis::Touch (Nis::slp_domain != slpdomain);
	    Nis::slp_domain = slpdomain;
	    Nis::Touch (false); //TODO need to know earlier for abort?
	    Nis::multidomain_servers = multidomain_servers;
	    Nis::Touch (false); //TODO need to know earlier for abort?
	    Nis::multidomain_broadcast = multidomain_broadcast;
	}

	Wizard::RestoreScreenShotName ();
	return (symbol) result;
    }

    /**
     * The switch dialog.
     * Selects NIS: off/on, Automount off/on
     * @return	`back, `abort, `next, `finish
     */
    define symbol SwitchDialog () ``{
	Wizard::SetScreenShotName ("nis-client-1-start");

	// help text 1/3
	string help_text = _("<p>Here, your machine can be set up as an
 <b>NIS client</b>.</p>
");

	// help text 3/3
	help_text = help_text + _("<p>The Network Information Service (NIS)
 was formerly known as Sun <b>Yellow Pages</b> (YP). The name Yellow
 Pages is a registered trademark in the United Kingdom by British
 Telecommunications plc and may not be used without
 permission.</p>");

	// help text 4/3
	string autofs_help_text = _("<p>Automounter is a daemon that mounts directories automatically,
such as users' home directories.
It is assumed that its configuration files (auto.*) already exist,
either locally or over NIS.<br>
If it is not installed and you want to use it, it will be installed
automatically.</p>");

	boolean yp_client = Mode::cont || Nis::start; // #23733
	boolean autofs = Nis::_start_autofs;

	term con = nil;
	term nis_frame =
	    // frame label
	    `Frame (_("NIS client"),
		    `VBox (`VSpacing (0.2),
			   `RadioButtonGroup (
			       `id (`rd),
			       `Left (
				   `HVSquash (
				       `VBox (
					   // radio button label
					   `Left (`RadioButton (`id (`nisno), `opt (`notify), _("Do &not use NIS"), !yp_client)),
					   // radio button label
					   `Left (`RadioButton (`id (`nisyes), `opt (`notify), _("&Use NIS"), yp_client))
					   )))),
			   `VSpacing (0.2)
			)
		);

	term autofs_frame =
	    `Frame (
		`opt (`hstretch),
		// frame label
		_("Automounter"),
		`VBox (
		    `VSpacing (0.2),
		    // check box label
		    `CheckBox (`id(`autofs), _("Start &Automounter"), autofs),
		    `VSpacing (0.2),
		    `Empty ()
		    )
		);

	if (Nis::_autofs_allowed)
	{
	    con = `HVSquash (`VBox (nis_frame, `VSpacing (1), autofs_frame));
	    help_text = help_text + autofs_help_text;
	}
	else
	{
	    con = `HVSquash (`VBox (nis_frame, `Empty (`id (`autofs))));
	}

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Configuration of NIS client"), con, help_text,
	    Label::BackButton (),
	    (yp_client || Mode::cont)? Label::NextButton (): Label::FinishButton ());

	// during installation, only enabling makes sence (#23831)
	if (Mode::cont)
	{
	    UI::ChangeWidget (`id(`nisno), `Enabled, false);
	    Wizard::ReplaceAbortButton (
		`PushButton(`id(`abort), Label::AbortInstallationButton()));
	}

	any result = nil;
	repeat
	{
	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }

	    yp_client = ((symbol) UI::QueryWidget (`id (`rd), `CurrentButton) != `nisno);

	    if (result == `nisyes || result == `nisno || result == `nisdhcp)
	    {
		UI::ChangeWidget (
		    `id (`next), `Label,
		    (yp_client || Mode::cont)? Label::NextButton(): Label::FinishButton ());
	    }
	}
	until (result == `back || result == `next ||
	       (result == `abort && ReallyAbort (Nis::touched)));

	if (result == `next)
	{
	    Nis::start = yp_client;
	    Nis::_start_autofs = Nis::_autofs_allowed && (boolean) UI::QueryWidget (`id (`autofs), `Value);
	    result = yp_client? result: `finish;
	}

	Wizard::RestoreScreenShotName ();
	return (symbol) result;
    }

    /**
     * Decide whether a complex dialog for multiple domains will be displayed
     * @return `yes or `no
     */
    define symbol IsMultiple () ``{
	return size (Nis::multidomain_servers) > 0 ? `yes: `no;
    }

    /**
     * Confirmation dialog
     * Also probes for packages that need to be installed (autofs)
     * #23050 don't display the dialog
     * @return `back or `next
     */
    define symbol SaveDialog () ``{
	Wizard::SetScreenShotName ("nis-client-3-save");
	// continue-cancel popup
	string message1 = _("The configuration of the NIS client will be saved.\n");
	string message2 = Nis::ProbePackages ();
	//boolean ret = Popup::ContinueCancel (message1 + message2);
	boolean ret = true;

	Wizard::RestoreScreenShotName ();
	return ret ? `next : `back;
    }

    map Dialogs = $[
	"switch":	``(SwitchDialog ()),
	"ismultiple":	[ ``(IsMultiple ()), true ],
	"single":	``(NisDialog ()),
	"multiple":	``(MultipleDialog ()),
	"expert":	``(ExpertDialog ()),
	"end":		``(SaveDialog ()),
	"common-next":	[ ``( JustNext () ), true ],
	];

    map Sequence = $[
	"ws_start"  : "switch",
	"switch"    : $[
	    `next   : "ismultiple",
	    `finish : "common-next",
	    `abort  : `abort,
	    ],
	"ismultiple": $[
	    `no     : "single",
	    `yes    : "multiple",
	    ],
	"single"       : $[
	    `next   : "common-next",
	    `multiple: "multiple",
	    `expert : "expert",
	    `abort  : `abort
	    ],
	"multiple"  : $[
	    `next   : "common-next",
	    `single : "single",
	    `expert : "expert",
	    `abort  : `abort
	    ],
	"expert"       : $[
	    `next   : "ismultiple",
	    `abort  : `abort
	    ],
	// This is will make AutoSequence finish without
	// confirmation. NormalSequence overrides it.
	"common-next" : $[
	    `next	: `next,
	    ],
	"end"       : $[
	    `next    : `next
	    ]
	];

    /**
     * Dhcpcd writes yp.conf in the multidomain form.
     * Let's try rewriting it so that it fits into the simple dialog.
     * It is done only after read.
     */
    define void FitIntoSingle () ``{
	if (Nis::dhcp_wanted && Nis::dhcp_possible)
	{
	    string d = Nis::GetDomain ();
	    if (size (Nis::multidomain_servers) == 1)
	    {
		list<string> s = Nis::multidomain_servers[d]:[];
		// if there's only one entry, for the correct domain
		if (size (s) > 0)
		{
		    y2milestone ("Fitting into the simple dialog");
		    Nis::servers = s;
		    Nis::multidomain_servers = $[];
		    Nis::default_broadcast = Nis::multidomain_broadcast[d]:false;
		    Nis::multidomain_broadcast = $[];
		}
	    }
	}
    }

    /**
     * The normal workflow
     * @return `back, `abort or `next
     */
    define symbol NormalSequence() ``{
	map normal_override = $[
	    "common-next": $[
		`next: "end",
		],
	    ];

	Wizard::CreateDialog ();

	if (Mode::screen_shot)
	{
	    Nis::Fake ();
	}
	else
	{
	    Nis::Read ();
	}

	FitIntoSingle ();

	// the second map must override the first!
	symbol result = WizardSequencer (Dialogs,
					 union (Sequence, normal_override));

	if (result == `next)
	{
	    if (Nis::start)
		// popup text FIXME better...
		Autologin::AskForDisabling(_("Now you have enabled NIS."));

	    // Install packages if needed.
	    // Cannot do it in Write, autoinstall does it differently.
	    if (size (Nis::install_packages) > 0 ||
		size (Nis::remove_packages) > 0)
	    {
		Require::DoInstallAndRemove (Nis::install_packages,
					     Nis::remove_packages);
	    }

	    if (Nis::Write ())
	    {
		if (Nis::start && Nis::DomainChanged ())
		{
		    // waring popup
		    Popup::Warning (_("The domain has changed.
You must reboot for the changes to take effect."));
		}
	    }
	}
	UI::CloseDialog();
	return result;
    }

    /**
     * The autoinstallation workflow
     * @return `back, `abort or `next
     */
    define symbol AutoSequence() ``{
	Wizard::CreateDialog ();
	symbol ret = WizardSequencer (Dialogs, Sequence);
	UI::CloseDialog ();
	return ret;
    }

}
