/**
 * File:
 *   include/nis/ui.ycp
 *
 * Package:
 *   Configuration of NIS
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{
    textdomain "nis";

    import "Wizard";
    import "Nis";

    include "ui/common_popups.ycp";
    include "network/ip.ycp";
    include "network/dns.ycp";

    global map Dialogs = $[
	"nis":	``(NisDialog ()),
	"expert":``(ExpertDialog ()),
	"end":	``(SaveDialog ()),
	];

    global map Sequence = $[
	"ws_start"  : "nis",
	"nis"       : $[
	    `next   : "end",
	    `expert : "expert",
	    `abort  : `abort
	    ],
	"expert"       : $[
	    `next   : "nis",
	    `abort  : `abort
	    ],
	"end"       : $[
	    `next    : `next
	    ]
	];

    /**
     * The main dialog
     * @return	`back, `abort, `next or `expert
     */
    global define symbol NisDialog () ``{
	// help text 1/3
	string help_text = _("<p>Here your machine can be set up as a
 <b>NIS client</b>. Just enter your NIS domain (e.g, suse.de) as the
 first entry and the NIS server's IP address (e.g., 10.20.0.2) as the second. To
 deactivate NIS services, select the <b>Do not use NIS</b> button.</p>");

	// help text 2/3
	help_text = help_text + _("<p>Specify multiple servers
by separating their addresses with spaces.</p>
");

	// help text 3/3
	help_text = help_text + _("<p>The Network Information Service (NIS)
 was formerly known as Sun <b>Yellow Pages</b> (YP). The name Yellow
 Pages is a registered trademark in the United Kingdom by British
 Telecommunications plc and may not be used without
 permission.</p>");

	// help text 4/3 (optional)
	string autofs_help_text = _(
"<p>Automounter is a daemon that mounts directories automatically.
It is assumed that its configuration files (auto.*) already exist,
either locally or over NIS.</p>");

	boolean yp_client = Nis::start;
	string yp_domain  = Nis::GetDomain ();
	string yp_address = Nis::GetServers ();
	boolean autofs = Nis::_start_autofs;

	term con = nil;
	term nis_frame =
	    // frame label
	    `Frame (_("NIS client"),
		    `VBox (`VSpacing (0.2),
			   `RadioButtonGroup (
			       `id (`rd),
			       `Left (
				   `HVSquash (
				       `VBox (
					   // radio button label
					   `Left (`RadioButton (`id (`nisno), `opt (`notify), _("Do &not use NIS"), !yp_client)),
					   // radio button label
					   `Left (`RadioButton (`id (`nisyes), `opt (`notify), _("&Use NIS"), yp_client))
					   )))),
			   // text entry label
			   `TextEntry (`id (`ypd), _("NIS &domain"), yp_domain),
			   // text entry label
			   `TextEntry (`id (`ypa), _("&IP addresses of NIS servers"), yp_address),
			   `VSpacing (0.2),
			   `PushButton (`id (`expert), _("D&etails ...")),
			   `VSpacing (0.2)
			)
		);

	term autofs_frame =
	    `Frame (
		`opt (`hstretch),
		// frame label
		_("Automounter"),
		`VBox (
		    `VSpacing (0.2),
		    // check box label
		    `CheckBox (`id(`autofs), _("Start &Automounter"), autofs),
		    `VSpacing (0.2),
		    `Empty ()
		    )
		);

	if (Nis::_autofs_allowed)
	{
	    con = `HVSquash (`VBox (nis_frame, `VSpacing (1), autofs_frame));
	    help_text = help_text + autofs_help_text;
	}
	else
	{
	    con = `HVSquash (`VBox (nis_frame, `Empty (`id (`autofs))));
	}

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Configuration of NIS client"), con, help_text,
	    BackButtonLabel (), FinishButtonLabel ());
	UI::ChangeWidget (`id (`ypd), `Enabled, yp_client);
	UI::ChangeWidget (`id (`ypa), `Enabled, yp_client);
	UI::ChangeWidget (`id (`expert), `Enabled, yp_client);
	UI::ChangeWidget (`id (`autofs), `Enabled, yp_client);

	any result = nil;
	repeat
	{
	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = abort;
	    }

	    yp_client = (UI::QueryWidget (`id (`rd), `CurrentButton) == `nisyes);

	    if (result == `nisyes || result == `nisno)
	    {
		UI::ChangeWidget (`id (`ypd), `Enabled, yp_client);
		UI::ChangeWidget (`id (`ypa), `Enabled, yp_client);
		UI::ChangeWidget (`id (`expert), `Enabled, yp_client);
		UI::ChangeWidget (`id (`autofs), `Enabled, yp_client);
	    }

	    if (result == `next && yp_client)
	    {
		yp_domain =  UI::QueryWidget (`id (`ypd), `Value);
		yp_address = UI::QueryWidget (`id (`ypa), `Value);

		if (!check_domainname (yp_domain))
		{
		    // error popup label
		    UI::MessagePopup (_("The domain name is not correct."));
		    result = nil;
		    continue;
		}

		list temp_ip = splitstring (yp_address, " ");
		if (contains (maplist (`i, temp_ip, ``(check_ip4 (i))), false))
		{
		    // error popup label
		    UI::MessagePopup (_("The IP address is not correct."));
		    result = nil;
		    continue;
		}
	    }
	}
	until (result == `back || result == `next || result == `expert ||
	       (result == `abort && UI::ReallyAbortPopup (Nis::touched)));

	if (result == `next)
	{
	    Nis::start = yp_client;
	    Nis::SetDomain (yp_domain);
	    Nis::SetServers (yp_address);
	    Nis::_start_autofs = Nis::_autofs_allowed && UI::QueryWidget (`id (`autofs), `Value);
	}

	return result;
    }


    /**
     * The expert dialog
     * @return	`back, `abort or `next
     */
    global define symbol ExpertDialog () ``{
	// help text 1/4
	string help_text = _("<p>Normally it is possible to query a client which server it is using. <b>Answer to the local host only</b> prevents it.</p>");

	// help text 2/4
	// network broadcast address
	help_text = help_text + _("<p><b>Use any server</b> ignores the server address entered in the previous dialog and uses a network broadcast in the local network to find a server. It is a security risk!</p>");

	// help text 3/4
	// Check, ie. turn on a check box
	help_text = help_text + _("<p>Check <b>Broken server</b> if answers from servers running on an unprivileged port should be accepted. It is a security risk and it is better to replace such a server.</p>");

	// help text 4/4
	help_text = help_text + _("<p>See <b>man ypbind</b> for details on other options.</p>");

	boolean local_only = Nis::local_only;
	boolean broadcast = Nis::broadcast;
	boolean broken_server = Nis::broken_server;
	string options = Nis::options;

	term contents =
	    `HVSquash (
		`VBox (
		    `VSpacing (0.2),
		    // check box label
		    `Left (`CheckBox (`id (`local_only), _("Answer to the &local host only"), local_only)),
		    // check box label
		    `Left (`CheckBox (`id (`broadcast), _("Use &any server"), broadcast)),
		    // check box label
		    `Left (`CheckBox (`id (`broken_server), _("&Broken server"), broken_server)),
		    `VSpacing (0.2),
		    // text entry label
		    // ypbind is the daemon name
		    `TextEntry (`id (`options), _("Other &ypbind options"), options),
		    `VSpacing (0.2)
		    )
		);

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Expert settings"), contents, help_text,
	    BackButtonLabel (), OKButtonLabel ());

	any result = nil;
	repeat
	{
	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = abort;
	    }

	    if (result == `next)
	    {
		local_only =  UI::QueryWidget (`id (`local_only), `Value);
		broadcast = UI::QueryWidget (`id (`broadcast), `Value);
		broken_server = UI::QueryWidget (`id (`broken_server), `Value);
		// TODO: disallow " in options
		options = UI::QueryWidget (`id (`options), `Value);

		if (false && some_error)
		{
		    // error popup label
		    UI::MessagePopup (_("The domain name is not correct."));
		    result = nil;

		}
	    }
	}
	until (result == `back || result == `next ||
	       (result == `abort && UI::ReallyAbortPopup (Nis::touched)));

	if (result == `next)
	{
	    Nis::Touch (Nis::local_only != local_only);
	    Nis::local_only = local_only;
	    Nis::Touch (Nis::broadcast != broadcast);
	    Nis::broadcast = broadcast;
	    Nis::Touch (Nis::broken_server != broken_server);
	    Nis::broken_server = broken_server;
	    Nis::Touch (Nis::options != options);
	    Nis::options = options;
	}

	return result;
    }


    /**
     * Confirmation dialog
     * @return `back or `next
     */
    global define symbol SaveDialog () ``{
	string message = _("The configuration of the NIS client will be saved.");
	if (UI::YesNoPopup (message))
	{
	    return `next;
	}

	return `back;
    }
}
