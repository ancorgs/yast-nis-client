/**
 * File:
 *   include/nis/ui.ycp
 *
 * Package:
 *   Configuration of NIS
 *
 * Summary:
 *   User interface functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 *
 * All user interface functions.
 *
 */

{
    textdomain "nis";

    import "Wizard";
    import "Nis";

    include "ui/common_popups.ycp";
    include "network/ip.ycp";
    include "network/dns.ycp";

    global map Dialogs = $[
	"switch":	``(SwitchDialog ()),
	"ismultiple":	[ ``(IsMultiple ()), true ],
	"single":	``(NisDialog ()),
	"multiple":	``(MultipleDialog ()),
	"expert":	``(ExpertDialog ()),
	"end":		``(SaveDialog ()),
	];

    global map Sequence = $[
	"ws_start"  : "switch",
	"switch"    : $[
	    `next   : "ismultiple",
	    `abort  : `abort,
	    ],
	"ismultiple": $[
	    `no     : "single",
	    `yes    : "multiple",
	    ],
	"single"       : $[
	    `next   : "end",
	    `multiple: "multiple",
	    `expert : "expert",
	    `abort  : `abort
	    ],
	"multiple"  : $[
	    `next   : "end",
	    `single : "single",
	    `expert : "expert",
	    `abort  : `abort
	    ],
	"expert"       : $[
	    `next   : "ismultiple",
	    `abort  : `abort
	    ],
	"end"       : $[
	    `next    : `next
	    ]
	];

    global /*const*/ string broadcast_help =
	// Translators: network broadcast address
	_("<p><b>Use any server</b> broadcasts in the local network to find a server. It is a security risk!</p>");

    /**
     * The switch dialog.
     * Selects NIS: off/on/on with dhcp, Automount off/on
     * @return	`back, `abort, `next
     */
    global define symbol SwitchDialog () ``{
	// help text 1/3
	string help_text = _("<p>Here your machine can be set up as a
 <b>NIS client</b>.<br><b>TODO</b> explain what it is, what is dhcp.</p>");

	// help text 3/3
	help_text = help_text + _("<p>The Network Information Service (NIS)
 was formerly known as Sun <b>Yellow Pages</b> (YP). The name Yellow
 Pages is a registered trademark in the United Kingdom by British
 Telecommunications plc and may not be used without
 permission.</p>");

	// help text 4/3 (optional)
	string autofs_help_text = _(
"<p>Automounter is a daemon that mounts directories automatically.
It is assumed that its configuration files (auto.*) already exist,
either locally or over NIS.</p>");

	boolean yp_client = Nis::start;
	boolean autofs = Nis::_start_autofs;

	term con = nil;
	term nis_frame =
	    // frame label
	    `Frame (_("NIS client"),
		    `VBox (`VSpacing (0.2),
			   `RadioButtonGroup (
			       `id (`rd),
			       `Left (
				   `HVSquash (
				       `VBox (
					   // radio button label
					   `Left (`RadioButton (`id (`nisno), `opt (`notify), _("Do &not use NIS"), !yp_client)),
					   // radio button label
					   `Left (`RadioButton (`id (`nisyes), `opt (`notify), _("&Use NIS"), yp_client)),
					   `Left (`RadioButton (`id (`nisdhcp), `opt (`notify), _("&Configure with DHCP")+ " [TODO!]", yp_client || false && TODO))
					   )))),
			   `VSpacing (0.2)
			)
		);

	term autofs_frame =
	    `Frame (
		`opt (`hstretch),
		// frame label
		_("Automounter"),
		`VBox (
		    `VSpacing (0.2),
		    // check box label
		    `CheckBox (`id(`autofs), _("Start &Automounter"), autofs),
		    `VSpacing (0.2),
		    `Empty ()
		    )
		);

	if (Nis::_autofs_allowed)
	{
	    con = `HVSquash (`VBox (nis_frame, `VSpacing (1), autofs_frame));
	    help_text = help_text + autofs_help_text;
	}
	else
	{
	    con = `HVSquash (`VBox (nis_frame, `Empty (`id (`autofs))));
	}

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Configuration of NIS client"), con, help_text,
	    BackButtonLabel (), NextButtonLabel ());
	UI::ChangeWidget (`id (`autofs), `Enabled, yp_client);

	any result = nil;
	repeat
	{
	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }

	    yp_client = (UI::QueryWidget (`id (`rd), `CurrentButton) != `nisno);

	    if (result == `nisyes || result == `nisno || result == `nisdhcp)
	    {
		UI::ChangeWidget (`id (`autofs), `Enabled, yp_client);
	    }
	}
	until (result == `back || result == `next ||
	       (result == `abort && UI::ReallyAbortPopup (Nis::touched)));

	if (result == `next)
	{
	    Nis::start = yp_client;
	    Nis::_start_autofs = Nis::_autofs_allowed && UI::QueryWidget (`id (`autofs), `Value);
	}

	return result;
    }

    /**
     * Decide whether a complex dialog for multiple domains will be displayed
     * @return `yes or `no
     */
    global define symbol IsMultiple () ``{
	return size (Nis::multidomain_servers) > 0 ? `yes: `no;
    }

    /**
     * The simple dialog
     * @return	`back, `abort, `next, `multiple or `expert
     */
    global define symbol NisDialog () ``{
	// help text 1/3
	string help_text = _("<p>Enter your NIS domain (e.g, suse.de)
 and the NIS server's IP address (e.g., 10.20.0.2).</p>");

	// help text 2/3
	help_text = help_text + _("<p>Specify multiple servers
by separating their addresses with spaces.</p>
");
	// help text 3/3
	help_text = help_text + broadcast_help;

	// help text 2/3
	help_text = help_text + _("<p>If you need to access <b>Multiple domains</b>, use the button to switch to a detailed dialog.</p>");


	string yp_domain  = Nis::GetDomain ();
	string yp_address = Nis::GetServers ();
	boolean broadcast = Nis::broadcast;

	term con = nil;
	term nis_frame =
	    // frame label
	    `Frame (_("NIS client"),
		    `VBox (`VSpacing (0.2),
			   // text entry label
			   `TextEntry (`id (`ypd), _("NIS &domain"), yp_domain),
			   // check box label
			   `Left (`CheckBox (`id (`broadcast), `opt (`notify), _("Use &any server"), broadcast)),
			   // text entry label
			   `TextEntry (`id (`ypa), _("&IP addresses of NIS servers"), yp_address),
			   `VSpacing (0.2),
			   `HBox (
			       `PushButton (`id (`expert), _("D&etails ...")),
			       `PushButton (`id (`multiple), _("&Multiple domains >>"))
			       ),
			   `VSpacing (0.2)
			)
		);

	con = `HVSquash (`VBox (nis_frame, `Empty (`id (`autofs))));

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Configuration of NIS client"), con, help_text,
	    BackButtonLabel (), FinishButtonLabel ());

	any result = nil;
	repeat
	{
	    UI::ChangeWidget (`id (`ypa), `Enabled, !broadcast);
	    UI::ChangeWidget (`id (`multiple), `Enabled, !broadcast);

	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }

	    broadcast = UI::QueryWidget (`id (`broadcast), `Value);

	    if (contains ([`next, `expert, `multiple], result))
	    {
		yp_domain =  UI::QueryWidget (`id (`ypd), `Value);
		yp_address = UI::QueryWidget (`id (`ypa), `Value);

		//TODO check_nisdomainname
		// Sun is permissive
		if (!check_domainname (yp_domain))
		{
		    // error popup label
		    UI::MessagePopup (_("The domain name is not correct."));
		    result = nil;
		    continue;
		}

		list temp_ip = splitstring (yp_address, " ");
		if (contains (maplist (`i, temp_ip, ``(check_ip4 (i))), false))
		{
		    // error popup label
		    UI::MessagePopup (_("The IP address is not correct."));
		    result = nil;
		    continue;
		}
	    }
	}
	until (result == `back || result == `next || result == `expert ||
	       result == `multiple ||
	       (result == `abort && UI::ReallyAbortPopup (Nis::touched)));

	if (contains ([`next, `expert, `multiple], result))
	{
	    Nis::SetDomain (yp_domain);
	    Nis::SetServers (yp_address);
	    Nis::Touch (Nis::broadcast != broadcast);
	    Nis::broadcast = broadcast;
	}

	return result;
    }


    /**
     * The expert dialog
     * @return	`back, `abort or `next
     */
    global define symbol ExpertDialog () ``{
	// help text 1/3
	string help_text = _("<p>Normally it is possible to query a client which server it is using. <b>Answer to the local host only</b> prevents it.</p>");

	// help text 2/3
	// Check, ie. turn on a check box
	help_text = help_text + _("<p>Check <b>Broken server</b> if answers from servers running on an unprivileged port should be accepted. It is a security risk and it is better to replace such a server.</p>");

	// help text 3/3
	help_text = help_text + _("<p>See <b>man ypbind</b> for details on other options.</p>");

	boolean local_only = Nis::local_only;
	boolean broken_server = Nis::broken_server;
	string options = Nis::options;

	term contents =
	    `HVSquash (
		`Frame (
		    _("Expert settings"),
		    `VBox (
			`VSpacing (0.2),
			// check box label
			`Left (`CheckBox (`id (`local_only), _("Answer to the &local host only"), local_only)),
			// check box label
			`Left (`CheckBox (`id (`broken_server), _("&Broken server"), broken_server)),
			`VSpacing (0.2),
			// text entry label
			// ypbind is the daemon name
			`TextEntry (`id (`options), _("Other &ypbind options"), options),
			`VSpacing (0.2)
			)
		    )
		);

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Expert settings"), contents, help_text,
	    BackButtonLabel (), OKButtonLabel ());

	any result = nil;
	repeat
	{
	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }

	    if (result == `next)
	    {
		local_only =  UI::QueryWidget (`id (`local_only), `Value);
		broken_server = UI::QueryWidget (`id (`broken_server), `Value);
		// TODO: disallow " in options
		options = UI::QueryWidget (`id (`options), `Value);

		if (false && some_error)
		{
		    // error popup label
		    UI::MessagePopup (_("The domain name is not correct."));
		    result = nil;

		}
	    }
	}
	until (result == `back || result == `next ||
	       (result == `abort && UI::ReallyAbortPopup (Nis::touched)));

	if (result == `next)
	{
	    Nis::Touch (Nis::local_only != local_only);
	    Nis::local_only = local_only;
	    Nis::Touch (Nis::broken_server != broken_server);
	    Nis::broken_server = broken_server;
	    Nis::Touch (Nis::options != options);
	    Nis::options = options;
	}

	return result;
    }

    /**
     * The servers dialog
     * @return	`back, `abort or `next
     */
    global define symbol MultipleDialog () ``{
	// variable naming: _d means _domain, _s means _server

	// help text 1/4
	string help_text = _("<p>Specify here the servers for multiple domains and select the default domain.</p>");

	// help text 3/3
	help_text = help_text + broadcast_help;

	// help text 3/3
	// network broadcast address
	help_text = help_text + _("<p><b>Use any server for this domain</b> broadcasts in the local network after the servers specified above fail to respond.</p>");

	// help text 3/3
	help_text = help_text + _("<p>If you do not need multiple domains, use <b>Single domain</b> to switch to a simpler dialog.</p>");

	string default_d = Nis::GetDomain ();
	boolean broadcast = Nis::broadcast;
	map multidomain_servers = Nis::multidomain_servers;
	multidomain_servers = add (multidomain_servers, "", Nis::servers);
	map multidomain_broadcast = Nis::multidomain_broadcast;

	// "" means the default domain
	string current_d = "";

	// build the dialog contents
	// depending on the UI, the domain and server selection boxes
	// are stacked horizontaly or vertically

	boolean horizontal = !lookup (UI::GetDisplayInfo (), "TextMode", false);
	term t_domains =
	    `VBox (
		`ReplacePoint (`id (`r_domains),
			       DomainBox (default_d, multidomain_servers)),
		`HBox (
		    `PushButton (`id (`add_d), _("A&dd")),
		    `PushButton (`id (`edit_d), _("&Edit")),
		    `PushButton (`id (`del_d), _("De&lete"))
		    )
		);
	term t_servers =
	    `VBox (
		`ReplacePoint (`id (`r_servers),
			       ServerBox (current_d, default_d, multidomain_servers)),
		`VBox (
		    `CheckBox (`id (`multidomain_broadcast),
			       _("Use any server &for this domain")),
		    `HBox (
			`PushButton (`id (`add_s), _("&Add")),
			`PushButton (`id (`edit_s), _("Ed&it")),
			`PushButton (`id (`del_s), _("Dele&te"))
			)
		    )
		);

	string note1 = "  [editable if Use any server is on]";
	string note2 = "  [disabled if Use any server is on]";

	term multiple =
	    `Frame (
		`id (`multiple), _("Server settings"),
		`VBox (
		    `VSpacing (0.2),
		    horizontal ?
		    `HBox (
			t_domains,
			`HSpacing (1),
			t_servers
			) :
		    `VBox (
			t_domains,
			t_servers
			),
		    `VSpacing (0.2)
		    )
		);

	// Another prototype BEGIN
	if (size (default_d) < 5)
	{
	multiple =
	    `Frame (
		`id (`multiple), _("Server settings"),
		`VBox (
		    `VSpacing (0.2),
		    `Table (
			`id (`domains),
			`opt (`notify, `immediate),
			`header (_("Domain"), _("Any server"), _("Servers")),
			DomainTableItems (default_d, multidomain_servers, multidomain_broadcast)
			),
		    `HBox (
			`PushButton (`id (`add_d), _("A&dd")),
			`PushButton (`id (`edit_d), _("Edi&t")),
			`PushButton (`id (`del_d), _("De&lete"))
			),
		    `VSpacing (0.2)
		    )
		);
	}
	// Another prototype END

	term nis_vbox =
	    `VBox (`VSpacing (0.2),
		   // text entry label
		   `TextEntry (`id (`domain), `opt (`notify), _("&Default NIS domain"), default_d),
		   `VSpacing (0.5),
		   // check box label
		   `Left (`CheckBox (`id (`broadcast), `opt (`notify), _("Use &any server"), broadcast)),
		   multiple,
		   `VSpacing (0.2),
		   `HBox (
		       `PushButton (`id (`expert), _("D&etails ...")),
		       `PushButton (`id (`single), _("&Single domain <<"))
		       ),
		   `VSpacing (0.2)
		);

	term nis_frame =
	    // frame label
	    `Frame (_("NIS client"), nis_vbox);

	term contents = nis_vbox;

	Wizard::SetContentsButtons (
	    // dialog title
	    _("Server settings"), contents, help_text,
	    BackButtonLabel (), FinishButtonLabel ());

	//UI::ChangeWidget (`id (`domains), `CurrentItem, current_d);

	any result = nil;
	string old_d = nil;	// circumvent not getting UserInput
	integer ui_count = 0;	// circumvent getting too many UserInputs
	integer last_domain_ui = -1;
	boolean domain_change_pending = false;
	// preselect an item
	// there is always the first item - the default domain
	UI::ChangeWidget (`id (`domains), `CurrentItem, "");

	repeat
	{
	    current_d = UI::QueryWidget (`id (`domains), `CurrentItem);
	    boolean any_d = current_d != nil;

	    UI::ChangeWidget (`id (`edit_d), `Enabled, any_d);
	    UI::ChangeWidget (`id (`del_d), `Enabled, any_d && current_d !="");
	    UI::ChangeWidget (`id (`add_s), `Enabled, any_d);

	    UI::ChangeWidget (`id (`multiple), `Enabled, !broadcast);

	    if (current_d != old_d)
	    {
		if (old_d != nil)
		{
		    multidomain_broadcast =
			add (multidomain_broadcast, old_d,
			     UI::QueryWidget (`id (`multidomain_broadcast),
					       `Value));
		}
		if (current_d == nil)
		{
		    current_d = "";//TODO:copied from nfsserver but should work
		}
		old_d = current_d;
		ServerBoxSet (current_d, default_d, multidomain_servers);
		BroadcastCheckSet (current_d, multidomain_broadcast);
	    }
	    boolean any_s = UI::QueryWidget (`id (`servers), `CurrentItem) != nil;
	    UI::ChangeWidget (`id (`edit_s), `Enabled, any_s);
	    UI::ChangeWidget (`id (`del_s), `Enabled, any_s);

	    result = UI::UserInput ();
	    if (result == `cancel)
	    {
		result = `abort;
	    }
	    ui_count = ui_count + 1;

	    broadcast = UI::QueryWidget (`id (`broadcast), `Value);

	    // ugh. TextEntry with notify sends UserInput after each character!
	    // But we do a replacewidget which is expensive. Must discard some
	    // of the UserInputs
	    if (result == `domain)
	    {
/*
		last_domain_ui = ui_count;
	    }
	    else if (ui_count == last_domain_ui + 1)
	    {
*/
		default_d = UI::QueryWidget (`id (`domain), `Value);
		// update the Default: item
		// TODO: (make an interface to do
		// just that, when the widget supports it)
		UI::ReplaceWidget (`id (`r_domains), DomainBox (default_d, multidomain_servers));
		UI::ChangeWidget (`id (`domains), `CurrentItem, current_d);
	    }

	    // switch
	    if (result == `add_d)
	    {
		string d = InputDomain ("", mapkeys (multidomain_servers));
		if (d != nil)
		{
		    multidomain_servers = add (multidomain_servers, d, []);
		    multidomain_broadcast = add (multidomain_broadcast, d, false);
		    // this also triggers updating the server list
		    UI::ReplaceWidget (`id (`r_domains), DomainBox (default_d, multidomain_servers));
		    UI::ChangeWidget (`id (`domains), `CurrentItem, d);
		    // TODO: add servers right away
		}
	    }
	    else if (result == `edit_d)
	    {
		string d0 = UI::QueryWidget (`id (`domains), `CurrentItem);
		if (d0 != nil)
		{
		    // editing the default domain is a special case
		    string def = (d0=="")? default_d: d0;
		    string d = InputDomain (def, mapkeys (multidomain_servers));
		    if (d != nil)
		    {
			string newkey = (d0=="")? "": d;
			multidomain_servers = mapmap (string k, any v, multidomain_servers, ``( [ (k==d0)? newkey: k, v]));
			multidomain_broadcast = mapmap (string k, any v, multidomain_broadcast, ``( [ (k==d0)? newkey: k, v]));
			// update the default domain box
			if (d0 == "")
			{
			    default_d = d;
			    UI::ChangeWidget (`id (`domain), `Value, default_d);
			}
			// this also triggers updating the server list
			UI::ReplaceWidget (`id (`r_domains), DomainBox (default_d, multidomain_servers));
			UI::ChangeWidget (`id (`domains), `CurrentItem, newkey);
		    }
		}
	    }
	    else if (result == `del_d)
	    {
		string d0 = UI::QueryWidget (`id (`domains), `CurrentItem);
		if (d0 != nil && d0 != "")
		{
		    // TODO confirmation
		    multidomain_servers = filter (string k, any v, multidomain_servers, ``( k != d0 ));
		    multidomain_broadcast = filter (string k, any v, multidomain_broadcast, ``( k != d0 ));
		    // this also triggers updating the server list
		    UI::ReplaceWidget (`id (`r_domains), DomainBox (default_d, multidomain_servers));
		    UI::ChangeWidget (`id (`domains), `CurrentItem, "");
		}
	    }
	    else if (result == `add_s)
	    {
		string d = UI::QueryWidget (`id (`domains), `CurrentItem);
		if (d != nil)
		{
		    list servers = multidomain_servers[d]:[];
		    string s = InputServer ("", servers);
		    if (s != nil)
		    {
			servers = add (servers, s);
			multidomain_servers = add (multidomain_servers, d, servers);
			ServerBoxSet (d, default_d, multidomain_servers);
			UI::ChangeWidget (`id (`servers), `CurrentItem, s);
		    }
		}
	    }
	    else if (result == `edit_s)
	    {
		string d = UI::QueryWidget (`id (`domains), `CurrentItem);
		string s0 = UI::QueryWidget (`id (`servers), `CurrentItem);
		if (d != nil && s0 != nil)
		{
		    list servers = multidomain_servers[d]:[];
		    string s = InputServer (s0, servers);
		    if (s != nil)
		    {
			servers = maplist (string e, servers, ``(
					       (e == s0)? s: e
					       ));
			multidomain_servers = add (multidomain_servers, d, servers);
			ServerBoxSet (d, default_d, multidomain_servers);
			UI::ChangeWidget (`id (`servers), `CurrentItem, s);
		    }
		}
	    }
	    else if (result == `del_s)
	    {
		string d = UI::QueryWidget (`id (`domains), `CurrentItem);
		string s0 = UI::QueryWidget (`id (`servers), `CurrentItem);
		if (d != nil && s0 != nil)
		{
		    // probably no confirmation.
		    list servers = multidomain_servers[d]:[];
		    servers = filter (string e, servers, ``( e != s0 ));
		    multidomain_servers = add (multidomain_servers, d, servers);
		    ServerBoxSet (d, default_d, multidomain_servers);
		    if (size (servers) > 0)
		    {
			s = servers[0]:"";
			UI::ChangeWidget (`id (`servers), `CurrentItem, s);
		    }
		}
	    }
	    else if (contains ([`next, `expert, `single], result))
	    {
		// Input validation
		default_d = UI::QueryWidget (`id (`domain), `Value);

		if (!check_nisdomainname (default_d))
		{
		    UI::SetFocus (`id (`domain));
		    UI::ErrorPopup (valid_nisdomainname ());
		    result = nil;
		    continue;
		}
		else
		{
		    // all checks OK, break the input loop
		    // TODO warn about discarding when `single
		    //  or warn before checking?
		    break;
		}
	    }
	}
	until (result == `back || result == `next ||
	       result == `expert || result == `single ||
	       (result == `abort && UI::ReallyAbortPopup (Nis::touched)));

	if (contains ([`next, `expert, `single], result))
	{
	    // TODO discard multidomain_* if `single
	    Nis::SetDomain (default_d);
	    Nis::Touch (Nis::broadcast != broadcast);
	    Nis::broadcast = broadcast;
	    list servers = multidomain_servers[""]:[];
	    Nis::Touch (Nis::servers != servers);
	    Nis::servers = servers;
	    multidomain_servers = filter (string k, any v, multidomain_servers, ``( k != "") );
	    Nis::Touch (false); //TODO need to know earlier for abort?
	    Nis::multidomain_servers = multidomain_servers;
	    multidomain_broadcast =
		add (multidomain_broadcast, current_d,
		     UI::QueryWidget (`id (`multidomain_broadcast), `Value));
	    multidomain_broadcast = filter (string k, any v, multidomain_broadcast, ``( k != "") );
	    Nis::Touch (false); //TODO need to know earlier for abort?
	    Nis::multidomain_broadcast = multidomain_broadcast;
	}

	return result;
    }

    /**
     * @param	m	a map
     * @return		keys of the map
     */
    global define list mapkeys (map m) ``{
	return maplist (any k, any v, m, ``( k ));
    }

    /**
     * Used for adding and editing a domain name
     * @param init	initial value ("" has no special significance here)
     * @param existing	current domain list
     * @return a domain or nil
     */
    global define string InputDomain (string init, list(string) existing) ``{
	string domain = init;

	term contents =
	    `HBox(
		`HSpacing(1),
		`VBox(
		    `VSpacing(0.2),
		    // Translators: popup dialog heading
//		    `Heading (_("Domain name")),
		    // Translators: text entry label
		    `Left (`TextEntry (`id (`domain), _("&Domain name"), domain)),
		    `VSpacing(0.2),
		    `HBox(`PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
			  `PushButton(`id(`cancel), CancelButtonLabel())),
		    `VSpacing(0.2)
		    ),
		`HSpacing(1)
		);

	UI::OpenDialog (`opt(`decorated), contents);
	UI::SetFocus (`id (`domain));

	any ret = nil;
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `cancel)
	    {
		break;
	    }
	    else if (ret == `ok)
	    {
		// Input validation
		domain = UI::QueryWidget (`id (`domain), `Value);

		if (!check_nisdomainname (domain)) //also disallows ""
		{
		    UI::SetFocus (`id (`domain));
		    UI::ErrorPopup (valid_nisdomainname ());
		}
		else if (contains (existing, domain) && domain != init)
		{
		    UI::SetFocus (`id (`domain));
		    // Translators: error message
		    UI::ErrorPopup (_("This domain is already defined."));
		}
		else
		{
		    // all checks OK, break the input loop
		    break;
		}
	    }
	}

	UI::CloseDialog ();
	return (ret == `ok)? domain : nil;
    }

    /**
     * Check syntax of a NIS domain name
     * @param domain	a domain name
     * @return		true if correct
     */
    global define boolean check_nisdomainname (string domain) ``{
	// TODO
	// disallow whitespace and special characters...
	return domain != "" && size (domain) <= 64;
    }

    /**
     * @return describe a valid NIS domain name
     */
    global define string valid_nisdomainname () ``{
	// TODO
	return _("A NIS domain name must not be empty
and it must be at most 64 characters long.");
    }

    /**
     * Constructs a whole SelectionBox
     * because we cannot replace its items (#8826)
     * @param	default_d	the default domain.
     * @param	multiple_ds	multiple-domain map
     * @return a SelectionBox
     */
    global define term DomainBox (string default_d, map multiple_ds) ``{
	return `SelectionBox (
	    `id (`domains), `opt (`notify, `shrinkable),
	    _("Do&mains"),
	    DomainListItems (default_d, multiple_ds)
	    );
    }

    /**
     * Constructs items for the domain selection box
     * @param	default_d	the default domain
     * @param	multiple_ds	multiple-domain map
     * @return a list of items
     * @see Nis#multidomain_servers
     */
    global define list DomainListItems (string default_d, map multiple_ds) ``{
	// Translators: the default NIS domain
	string dd = sformat (_("Default: %1"), default_d);
	// maps are sorted, so the default domain, "", comes first
	return maplist (string d, any value, multiple_ds, ``(
			    `item (`id (d), (d == "")? dd: d)
			    ));
    }

    /**
     * Constructs items for the domain table
     * @param	default_d	the default domain
     * @param	multiple_ds	multiple-domain map
     * @param	multiple_b	multiple-domain broadcast
     * @return a list of items
     * @see Nis#multidomain_servers
     */
    global define list DomainTableItems (string default_d, map multiple_ds, map multiple_b) ``{
	// Translators: the default NIS domain
	string dd = sformat (_("Default: %1"), default_d);
	// maps are sorted, so the default domain, "", comes first
	return maplist (string d, list servers, multiple_ds, ``(
			    `item (
				`id (d),
				(d == "")? dd: d,
				multiple_b[d]:false? "X": "",	// TODO glyph?
				mergestring (servers, ", ")
				)
			    ));
    }

    /**
     * Updates the server box when a domain has changed
     * @param	domain	a new domain. "" is the defauld domain.
     * @param	multiple_b	multiple-domain broadcasts
     */
    global define void BroadcastCheckSet (string domain, map multiple_b) ``{
	UI::ChangeWidget (`id (`multidomain_broadcast), `Enabled, domain !="");
	UI::ChangeWidget (`id (`multidomain_broadcast), `Value,
			  multiple_b[domain]:false);
    }

    /**
     * Used for adding and editing a server
     * TODO: IPs or names?
     * @param init	initial value
     * @param existing	current server list (excluding default?)
     * @return a server or nil
     */
    global define string InputServer (string init, list(string) existing) ``{
	string server = init;

	term contents =
	    `HBox(
		`HSpacing(1),
		`VBox(
		    `VSpacing(0.2),
		    // Translators: popup dialog heading
//		    `Heading (_("Server address")),
		    // Translators: text entry label
		    `Left (`TextEntry (`id (`server), _("&Server address"), server)),
		    `VSpacing(0.2),
		    `HBox(`PushButton(`id(`ok), `opt(`default), OKButtonLabel()),
			  `PushButton(`id(`cancel), CancelButtonLabel())),
		    `VSpacing(0.2)
		    ),
		`HSpacing(1)
		);

	UI::OpenDialog (`opt(`decorated), contents);
	UI::SetFocus (`id (`server));

	any ret = nil;
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `cancel)
	    {
		break;
	    }
	    else if (ret == `ok)
	    {
		// Input validation
		server = UI::QueryWidget (`id (`server), `Value);

		if (!check_domainname (server)) //TODO ip or name?
		{
		    UI::SetFocus (`id (`server));
		    UI::ErrorPopup (valid_domainname ());
		}
		else if (contains (existing, server) && server != init)
		{
		    UI::SetFocus (`id (`server));
		    // Translators: error message
		    UI::ErrorPopup (_("This server is already specified."));
		}
		else
		{
		    // all checks OK, break the input loop
		    break;
		}
	    }
	}

	UI::CloseDialog ();
	return (ret == `ok)? server : nil;
    }

    /**
     * Updates the server box when a domain has changed
     * @param	domain	a new domain. "" is the default domain.
     * @param	default_d	the default domain.
     * @param	multiple_ds	multiple-domain map
     */
    global define void ServerBoxSet (string domain, string default_d, map multiple_ds) ``{
	UI::ReplaceWidget (`id (`r_servers), ServerBox (domain, default_d, multiple_ds));
    }

    /**
     * Constructs a whole SelectionBox
     * because we cannot replace its items (#8826)
     * @param	domain	a new domain. "" is the default domain.
     * @param	default_d	the default domain.
     * @param	multiple_ds	multiple-domain map
     * @return a SelectionBox
     */
    global define term ServerBox (string domain, string default_d, map multiple_ds) ``{
	// Translators: part of "Servers for the default domain"
	string label = (domain == "")? _("the default domain"): domain;
	return `SelectionBox (
	    `id (`servers), `opt (`notify, `shrinkable),
	    // Translators: %1 is a domain name or "the default domain" above
	    sformat (_("Servers for %1"), label),
	    ServerListItems (domain, multiple_ds) );
    }

    /**
     * Constructs items for the server selection box
     * @param	domain		a domain. "" is the default domain.
     * @param	multiple_ds	multiple-domain map
     * @return a list of items
     * @see Nis#multidomain_servers
     */
    global define list ServerListItems (string domain, map multiple_ds) ``{
	return multiple_ds[domain]:[];
    }


    /**
     * Confirmation dialog
     * @return `back or `next
     */
    global define symbol SaveDialog () ``{
	string message = _("The configuration of the NIS client will be saved.");
	if (UI::YesNoPopup (message))
	{
	    return `next;
	}

	return `back;
    }

    // TODO: update to the new workflow
    global define symbol AutoSequence() ``{
	map dlg = $[
			"nis":	``(NisDialog ()),
			"expert":``(ExpertDialog ())
	];

	map seq = $[
			 "ws_start"  : "nis",
			 "nis"       : $[
					 `next   : `next,
					 `expert : "expert",
					 `abort  : `abort
			 ],
			 "expert"       : $[
					    `next   : "nis",
					    `abort  : `abort
			 ]
	];

	Wizard::CreateDialog ();
	Wizard::ReplaceAbortButton(`Empty ());
	symbol ret = WizardSequencer (dlg, seq);
	UI::CloseDialog ();
	return ret;
    }
}
