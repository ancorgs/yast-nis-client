#!/usr/bin/perl -w
#
# $Id$
# Author: Martin Vidner <mvidner@suse.cz>
#
# An agent for parsing and writing /etc/yp.conf.
# Only ypserver is supported.

# $comment: all comments, separated by newlines.
#  they will be written to the beginning of file
# @servers: a list of ypservers (for the local domain)
# %domainservers:  keys are domains, values are lists of servers
#  an empty list means broadcast

use lib "/usr/lib/YaST2/agents_non_y2";
use ycp;
use strict;
use Errno qw(ENOENT);

my $comment;
my @servers;
my %domainservers;

my $filename;
my $modified;

# return false if an error occurred
sub parse_file ()
{
    $comment = "";
    @servers = ();
    %domainservers = ();

    if (!open (FILE, $filename))
    {
	return 1 if ($! == ENOENT); # ok if it is not there
	y2error ("$filename: $!");
	return 0;
    }

    while (<FILE>)
    {
	chomp;
	if (s/\#(.*)//)		# get comments
	{
	    $comment .= "$1\n";
	}
	s/^\s*//;		# strip leading whitespace
	next if /^$/;		# skip empty lines
	if (/^ypserver\s+(\S+)/)
	{
	    push @servers, $1;
	}
	elsif (/^domain\s+(\S+)\s+server\s+(\S+)/)
	{
	    push @{$domainservers{$1}}, $2;
	}
	elsif (/^domain\s+(\S+)\s+broadcast/)
	{
	    $domainservers{$1} = [];
	}
	else
	{
	    y2error ("Parse error: <$_>");
	    close (FILE);
	    return 0;
	}
    }
    close (FILE);
    return 1;
}

sub write_file ()
{
    return 1 if (! $modified);

    open (FILE, ">$filename.YaST2.new") or return y2error ("$filename: $!"), 0;

    foreach (split /\n/, $comment)
    {
	print FILE "#$_\n";
    }
    foreach (@servers)
    {
	print FILE "ypserver $_\n";
    }
    foreach my $domain (sort keys %domainservers)
    {
	if (@{$domainservers{$domain}} == 0)
	{
	    print FILE "domain $domain broadcast\n";
	}
	else
	{
	    foreach my $server (@{$domainservers{$domain}})
	    {
		print FILE "domain $domain server $server\n";
	    }
	}
    }
    close (FILE);

    if (-f $filename)
    {
	rename $filename, "$filename.YaST2.save" or return y2error ("$filename: $!"), 0;
    }
    rename "$filename.YaST2.new", $filename or return  y2error ("$filename: $!"), 0;
    $modified = 0;
    return 1;
}


#
# MAIN cycle
#

# read the agent arguments
$_ = <STDIN>;
# no input at all - simply exit
exit if ! defined $_;
# reply to the client (this actually gets eaten by the ScriptingAgent)
ycp::Return (undef);
print "\n";

my ($symbol, $fn, undef) = ycp::ParseTerm ($_);
if ($symbol ne "YpConf")
{
    y2error ("The first command must be the configuration.(Seen '$_')");
    exit;
}
else
{
    $filename = $fn || "/etc/yp.conf";
}


# if reading fails, defaulting to no servers
# TODO error state - copy from another agent
parse_file ();
$modified = 0;

while ( <STDIN> )
{
    my ($command, $path, $argument) = ycp::ParseCommand ($_);

    if ($command eq "Dir")
    {
	if ($path eq ".")
	{
	    ycp::Return (["comment", "domainservers", "servers"]);
	}
	else
	{
	    ycp::Return ([]);
	}
    }

    elsif ($command eq "Write")
    {
	my $result = "true";
	if ($path eq ".servers" && ref ($argument) eq "ARRAY")
	{
	    @servers = @{$argument};
	    $modified = 1;
	}
	elsif ($path eq ".domainservers" && ref ($argument) eq "HASH")
	{
	    foreach my $v (values %{$argument})
	    {
		if (ref ($v) ne "ARRAY")
		{
		    y2error ("Domainservers value not a list: $v");
		    $result = "false";
		    last;
		}
	    }
	    if ($result eq "true")
	    {
		%domainservers = %{$argument};
		$modified = 1;
	    }
	}
	elsif ($path eq ".comment" && !ref ($argument))
	{
	    $comment = $argument;
	    $modified = 1;
	}
	elsif ($path eq "." && !defined ($argument))
	{
	    $result = write_file () ? "true":"false";
	}
	elsif ($path eq "." && ref($argument) eq "HASH")
	{
	    # a hack to make testing simple
	    $comment = $argument->{"comment"};
	    @servers = @{$argument->{"servers"}};
	    %domainservers = %{$argument->{"domainservers"}};
	    $modified = 1;
	}
	else
	{
	    y2error ("Wrong path $path or argument: ", ref ($argument));
	    $result = "false";
	}

	ycp::Return ($result);
    }

    elsif ($command eq "Read")
    {
	if ($path eq ".servers")
	{
	    ycp::Return (\@servers);
	}
	elsif ($path eq ".domainservers")
	{
	    ycp::Return (\%domainservers);
	}
	elsif ($path eq ".comment")
	{
	    ycp::Return ($comment);
	}
	elsif ($path eq ".")
	{
	    # a hack to make testing simple
	    ycp::Return ({
			  "comment" => $comment,
			  "domainservers" => \%domainservers,
			  "servers" => \@servers,
			  });
	}
	else
	{
	    y2error ("Unrecognized path! '$path'");
	    ycp::Return (undef);
	}
    }

    elsif ($command eq "result")
    {
	last;
    }

    # Unknown command
    else
    {
	y2error ("Unknown instruction $command or argument: ", ref ($argument));
	ycp::Return (undef);
    }
    print "\n";
}

write_file ();
